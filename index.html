<!DOCTYPE html>
<html>
  <head>
    <title>3D Scene</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap");
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
      #prompt {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        font-family: sans-serif;
        font-size: 24px;
        display: none;
      }
      #score {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        font-family: "Press Start 2P", cursive;
        font-size: 72px;
      }

      @keyframes score-animation {
        0% {
          transform: translateX(-50%) scale(1);
        }
        50% {
          transform: translateX(-50%) scale(1.5);
          color: #ffc107;
        }
        100% {
          transform: translateX(-50%) scale(1);
        }
      }

      .score-animated {
        animation: score-animation 0.3s;
      }

      @keyframes health-bar-shake {
        0% {
          transform: translateX(-50%) scaleX(1);
        }
        25% {
          transform: translateX(-52%) scaleX(1.05);
        }
        50% {
          transform: translateX(-48%) scaleX(1.05);
        }
        75% {
          transform: translateX(-52%) scaleX(1.05);
        }
        100% {
          transform: translateX(-50%) scaleX(1);
        }
      }

      @keyframes spacebar-press {
        from {
          transform: translateX(-50%) scale(1);
        }
        to {
          transform: translateX(-50%) scale(0.95);
        }
      }

      .spacebar-active {
        animation: spacebar-press 0.2s forwards;
      }

      .health-bar-shaking {
        animation: health-bar-shake 0.3s;
      }

      #health-bar-container {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        width: 600px;
        height: 40px;
        border: 2px solid white;
        box-shadow: 0 0 10px white, 0 0 20px white, 0 0 30px #00bfff;
      }

      #health-bar {
        width: 100%;
        height: 100%;
        background-color: red;
        transition: width 0.2s ease;
      }

      #level-up-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(16, 16, 16, 0.85);
        display: none; /* Hidden by default */
        justify-content: center;
        align-items: center;
        z-index: 100;
        font-family: "Press Start 2P", cursive;
      }

      #level-up-popup {
        background: rgba(30, 30, 30, 0.9);
        border: 3px solid #00bfff;
        box-shadow: 0 0 20px #00bfff;
        padding: 30px;
        text-align: center;
        color: white;
        transform: scale(0);
        transition: transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        width: 90%;
        max-width: 500px;
        position: relative;
      }

      #level-up-overlay.visible {
        display: flex;
      }

      #level-up-overlay.visible #level-up-popup {
        transform: scale(1);
      }

      #level-up-popup h2 {
        color: gold;
        text-shadow: 0 0 10px gold;
        margin-top: 0;
      }

      #upgrade-options {
        position: absolute;
        bottom: 20px;
        right: 20px;
        display: flex;
        flex-direction: column;
        gap: 15px;
      }

      .upgrade-button {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        border: 3px solid white;
        color: white;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        transition: transform 0.1s, box-shadow 0.2s;
        font-size: 10px;
        padding: 5px;
        box-sizing: border-box;
      }

      .upgrade-button:hover {
        transform: scale(1.1);
      }

      .upgrade-button .stat-name {
        font-weight: bold;
      }

      .upgrade-button .stat-value {
        margin-top: 5px;
        font-size: 12px;
      }

      #skip-button-container {
        width: 80px;
        height: 30px;
        margin-top: 15px;
        border: 2px solid white;
        cursor: pointer;
        padding: 2px;
        box-sizing: border-box;
      }

      #skip-button-progress {
        width: 100%;
        height: 100%;
        background-color: #00ff00;
        transition: width 0.1s linear, background-color 0.5s linear;
      }

      #skip-button-text {
        position: absolute;
        bottom: 28px; /* Aligns with the container */
        right: 20px;
        width: 80px;
        color: white;
        font-size: 12px;
        pointer-events: none; /* Text doesn't block clicks */
      }

      #gem-counters {
        position: absolute;
        top: 90px; /* Below level */
        left: 20px;
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 5px 15px;
        font-family: "Press Start 2P", cursive;
        font-size: 14px;
        color: white;
      }
      .gem-counter {
        text-shadow: 0 0 5px black, 0 0 8px black;
      }
    </style>
  </head>
  <body>
    <div id="score">0</div>
    <div
      id="level-container"
      style="
        position: absolute;
        top: 20px;
        left: 20px;
        color: gold;
        font-family: 'Press Start 2P', cursive;
        font-size: 60px;
      "
    >
      lvl <span id="level">1</span>
    </div>
    <div id="gem-counters">
      <span id="gem-damage" class="gem-counter" style="color: #ff0000;">0</span>
      <span id="gem-speed" class="gem-counter" style="color: #00ff00;">0</span>
      <span id="gem-attackSpeed" class="gem-counter" style="color: #800080;">0</span>
      <span id="gem-luck" class="gem-counter" style="color: #ffffff;">0</span>
      <span id="gem-vacuum" class="gem-counter" style="color: #0000ff;">0</span>
      <span id="gem-crit" class="gem-counter" style="color: #ffff00;">0</span>
    </div>
    <div
      id="experience-bar-container"
      style="
        position: absolute;
        bottom: 70px;
        left: 50%;
        transform: translateX(-50%);
        width: 600px;
        height: 15px;
        border: 2px solid gold;
      "
    >
      <div
        id="experience-bar"
        style="width: 0%; height: 100%; background-color: gold"
      ></div>
    </div>
    <div
      id="stats-container"
      style="
        position: absolute;
        top: 20px;
        right: 20px;
        color: white;
        font-family: 'Press Start 2P', cursive;
        font-size: 16px;
        text-align: right;
      "
    >
      <div>Attack Speed: <span id="stat-attack-speed">2.00</span></div>
      <div>Damage: <span id="stat-damage">30</span></div>
      <div>Luck: <span id="stat-luck">50</span>%</div>
      <div>Pickup Radius: <span id="stat-pickup-radius">15</span></div>
      <div>Crit Chance: <span id="stat-crit-chance">5</span>%</div>
      <div>Armor: <span id="stat-armor">0</span></div>
      <div>Regen/s: <span id="stat-regen">0.0</span></div>
      <div>Dodge: <span id="stat-dodge">0</span>%</div>
      <div>Pierce: <span id="stat-pierce">1</span></div>
      <div>AoE Radius: <span id="stat-aoe">0</span></div>
    </div>
    <div id="health-bar-container">
      <div id="health-bar"></div>
    </div>
    <div
      id="spacebar-symbol"
      style="
        position: absolute;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        display: none;
      "
    >
      <div
        style="
          height: 100px;
          background-color: white;
          border-radius: 10px;
          display: flex;
          align-items: center;
          justify-content: center;
          color: black;
          font-family: 'Press Start 2P', cursive;
          font-size: 24px;
        "
      >
      </div>
    </div>
    <button
      id="reset-button"
      style="
        position: absolute;
        top: 60%;
        left: 50%;
        transform: translateX(-50%);
        padding: 15px 30px;
        font-size: 24px;
        font-family: 'Press Start 2P', cursive;
        background-color: #00bfff;
        color: white;
        border: none;
        cursor: pointer;
        display: none;
      "
    >
      Reset Game
    </button>

    <div id="level-up-overlay">
      <div id="level-up-popup">
        <h2>LEVEL UP!</h2>
        <p>Choose an upgrade</p>
        <div id="upgrade-options">
          <!-- Buttons will be generated here -->
          <div id="skip-button-container">
            <div id="skip-button-progress"></div>
          </div>
        </div>
        <div id="skip-button-text">Skip</div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
              console.log("Script started");
              // Scene
              const scene = new THREE.Scene();
              scene.background = new THREE.Color(0x101010);

                              const ambientLight = new THREE.AmbientLight(0x9932CC, 0.3);
              scene.add(ambientLight);

              // Camera
              const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

              // Renderer
              const renderer = new THREE.WebGLRenderer({ antialias: true });
              renderer.setSize(window.innerWidth, window.innerHeight);
              renderer.shadowMap.enabled = true;
              document.body.appendChild(renderer.domElement);

              // Ground Plane
              const planeGeometry = new THREE.PlaneGeometry(2000, 2000);
              const planeMaterial = new THREE.MeshStandardMaterial({ color: 0xC2B280, side: THREE.DoubleSide, metalness: 0.2, roughness: 0.8 });
              const plane = new THREE.Mesh(planeGeometry, planeMaterial);
              plane.rotation.x = -Math.PI / 2;
              plane.receiveShadow = true;
              scene.add(plane);

              // Octahedrons
              const octahedronGroups = [];
              const octahedronGeometry = new THREE.OctahedronGeometry(24);

      function spawnOctahedrons(count = 2, nearPlayer = true) {
          const minDistance = 100;   // base spacing
          const radius = 24;         // radius of octahedrons

          for (let i = 0; i < count; i++) {
              let position;
              let tooClose;
              let attempts = 0;

              do {
                  tooClose = false;
                  if (nearPlayer) {
                      // Expanded spawn range around player
                      position = new THREE.Vector3(
                          (Math.random() - 0.5) * 200,
                          120,
                          (Math.random() - 0.5) * 200
                      );
                  } else {
                      position = new THREE.Vector3(
                          (Math.random() - 0.5) * 980,
                          120,
                          (Math.random() - 0.5) * 980
                      );
                  }

                  for (const group of octahedronGroups) {
                      const requiredSpacing = minDistance + radius * 2;
                      if (position.distanceTo(group.octahedron.position) < requiredSpacing) {
                          tooClose = true;
                          break;
                      }
                  }

                  attempts++;
                  if (attempts > 100) {
                      console.warn("Could not place octahedron after 100 attempts");
                      break;
                  }
              } while (tooClose);

                              const octahedronMaterialInstance = new THREE.MeshStandardMaterial({ color: 0x9932CC, flatShading: true, emissive: 0x9932CC, emissiveIntensity: 0.5 });
              const octahedron = new THREE.Mesh(octahedronGeometry, octahedronMaterialInstance);
              octahedron.position.copy(position);
              octahedron.castShadow = false;
              scene.add(octahedron);

              const ring = new THREE.Mesh(
                  new THREE.RingGeometry(25, 27, 32),
                  new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 })
              );
              ring.position.set(octahedron.position.x, 0.1, octahedron.position.z);
              ring.rotation.x = -Math.PI / 2;
              scene.add(ring);

                              const light = new THREE.PointLight(0x9932CC, 2, 200);
              light.position.copy(octahedron.position); // ✅ fixed
              light.position.y += 10;                   // ✅ correct Y adjustment
              light.castShadow = false;
              scene.add(light);

              const initialY = 120;
              octahedronGroups.push({
                  octahedron,
                  ring,
                  light,
                  health: 500,
                  maxHealth: 500,
                  radius: 24,
                  state: 'idle',
                  lastShotTime: 0,
                  animationProgress: 0,
                  initialY: initialY,
                  conversionProgress: 0
              });
          }
      }


              // Call it initially
              spawnOctahedrons(2, true);

                      // Moonlight
              const moonlight = new THREE.DirectionalLight(0xC0C0C0, 0.3);
              moonlight.position.set(0, 100, 100);
              scene.add(moonlight);



                      // Player Cone
              const playerConeOriginalColor = new THREE.Color(0x00ff00);
              const playerCone = new THREE.Mesh(
                  new THREE.ConeGeometry(1.5, 6, 32),
                  new THREE.MeshStandardMaterial({ color: playerConeOriginalColor, emissive: 0x00ff00, emissiveIntensity: 1, toneMapped: false })
              );
              playerCone.position.set(0, 3, 5);
              scene.add(playerCone);

              const coneLight = new THREE.PointLight(0x00ff00, 1, 10);
              playerCone.add(coneLight);

              const playerStats = {
                  attackDistance: 100,
                  projectileSpeed: 3,
                  damage: 30,
                  areaDamageRadius: 0,
                  pierceCount: 1,
                  critChance: 0.05,
                  critMultiplier: 2,
                  maxHealth: 100,
                  armor: 0,
                  regenRate: 0,
                  dodgeChance: 0,
                  attackSpeed: 0.5, // Cooldown in seconds
                  pickupRadius: 15,
                  playerRadius: 1.5,
                  coinPickupRadius: 115,
                  luck: 0.5,
                  cooldownReduction: 0
              };

              function updateStatsUI() {
                  const effectiveCooldown = playerStats.attackSpeed * (1 - playerStats.cooldownReduction);
                  document.getElementById('stat-attack-speed').textContent = (1 / effectiveCooldown).toFixed(2);
                  document.getElementById('stat-damage').textContent = playerStats.damage;
                  document.getElementById('stat-luck').textContent = `${(playerStats.luck * 100).toFixed(0)}%`;
                  document.getElementById('stat-pickup-radius').textContent = playerStats.pickupRadius;
                  document.getElementById('stat-crit-chance').textContent = `${(playerStats.critChance * 100).toFixed(0)}%`;
                  document.getElementById('stat-armor').textContent = playerStats.armor;
                  document.getElementById('stat-regen').textContent = playerStats.regenRate.toFixed(1);
                  document.getElementById('stat-dodge').textContent = `${(playerStats.dodgeChance * 100).toFixed(0)}%`;
                  document.getElementById('stat-pierce').textContent = playerStats.pierceCount;
                  document.getElementById('stat-aoe').textContent = playerStats.areaDamageRadius;
              }

              const spacebarSymbol = document.getElementById('spacebar-symbol');

              // Change prompt text and size based on device
              const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
              const spacebarPromptDiv = spacebarSymbol.querySelector('div');
              if (isTouchDevice) {
                  spacebarPromptDiv.textContent = 'HOLD';
                  spacebarPromptDiv.style.width = '300px';
              } else {
                  spacebarPromptDiv.textContent = 'Hold SPACE';
                  spacebarPromptDiv.style.width = '400px';
              }

              spacebarSymbol.addEventListener('mousedown', () => {
                  keyState['Space'] = true;
              });

              spacebarSymbol.addEventListener('mouseup', () => {
                  keyState['Space'] = false;
              });

              spacebarSymbol.addEventListener('mouseleave', () => {
                  keyState['Space'] = false;
              });

              spacebarSymbol.addEventListener('touchstart', (event) => {
                  event.preventDefault(); // Prevent mouse events from being fired
                  keyState['Space'] = true;
              });

              spacebarSymbol.addEventListener('touchend', () => {
                  keyState['Space'] = false;
              });

              spacebarSymbol.addEventListener('touchleave', () => {
                  keyState['Space'] = false;
              });

              // Movement system
              const keyState = {};
              window.addEventListener('keydown', (e) => { keyState[e.code] = true; });
              window.addEventListener('keyup', (e) => { keyState[e.code] = false; });

              // Touch/Mouse movement system
              let isDragging = false;
              let dragStartPoint = null;
              let movementDirection = new THREE.Vector2();

              // Visual elements for drag
              let dragDot = null;
              let dragLine = null;

              function createDragVisuals(x, y) {
          // Remove existing visuals
          if (dragDot) {
              scene.remove(dragDot);
              dragDot = null;
          }
          if (dragLine) {
              scene.remove(dragLine);
              dragLine = null;
          }

          // Store drag start in screen coordinates (for joystick base)
          dragStartPoint = new THREE.Vector2(x, y);

          // Create black dot in screen space (2D overlay instead of 3D)
          dragDot = document.createElement('div');
          dragDot.style.position = 'absolute';
          dragDot.style.width = '20px';
          dragDot.style.height = '20px';
          dragDot.style.background = 'black';
          dragDot.style.borderRadius = '50%';
          dragDot.style.left = `${x - 10}px`;
          dragDot.style.top = `${y - 10}px`;
          dragDot.style.pointerEvents = 'none'; // ignore clicks
          document.body.appendChild(dragDot);
      }


              function updateDragLine(endX, endY) {
          if (!dragStartPoint) return;

          // Remove old line
          if (dragLine) {
              document.body.removeChild(dragLine);
              dragLine = null;
          }

          // Create a line in screen space (simple div for now)
          dragLine = document.createElement('div');
          dragLine.style.position = 'absolute';
          dragLine.style.background = 'white';
          dragLine.style.height = '4px';
          dragLine.style.transformOrigin = '0 50%';

          const dx = endX - dragStartPoint.x;
          const dy = endY - dragStartPoint.y;
          const length = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx) * (180 / Math.PI);

          dragLine.style.width = `${length}px`;
          dragLine.style.left = `${dragStartPoint.x}px`;
          dragLine.style.top = `${dragStartPoint.y}px`;
          dragLine.style.transform = `rotate(${angle}deg)`;

          document.body.appendChild(dragLine);

          // ✅ Update movement direction based on drag vector
          const direction = new THREE.Vector2(dx, dy);
          if (direction.length() > 10) { // threshold
              movementDirection.set(direction.x, direction.y).normalize();
              // note: -dy because screen y is inverted relative to 3D world z
          } else {
              movementDirection.set(0, 0);
          }
      }
      function endDrag() {
          if (isDragging) {
              isDragging = false;
              movementDirection.set(0, 0);
              clearDragVisuals();
          }
      }


              function clearDragVisuals() {
          if (dragDot) {
              document.body.removeChild(dragDot);
              dragDot = null;
          }
          if (dragLine) {
              document.body.removeChild(dragLine);
              dragLine = null;
          }
          dragStartPoint = null;
      }


              // Mouse events
      renderer.domElement.addEventListener('mousedown', (event) => {
          if (isGameOver) return; // ✅ ignore if game over
          if (event.button === 0) { // left click
              isDragging = true;
              createDragVisuals(event.clientX, event.clientY);
              event.preventDefault();
          }
      });


      renderer.domElement.addEventListener('mousemove', (event) => {
          if (isGameOver) return;
          if (isDragging) {
              updateDragLine(event.clientX, event.clientY);
          }
      });


      window.addEventListener('mouseup', (event) => {
          if (isGameOver) return;
          if (event.button === 0) {
              endDrag();
          }
      });


              // Touch events
      renderer.domElement.addEventListener('touchstart', (event) => {
          if (isGameOver) return;
          if (event.touches.length === 1) {
              const touch = event.touches[0];
              isDragging = true;
              createDragVisuals(touch.clientX, touch.clientY);
              event.preventDefault();
          }
      });

      renderer.domElement.addEventListener('touchmove', (event) => {
          if (isGameOver) return;
          if (isDragging && event.touches.length === 1) {
              const touch = event.touches[0];
              updateDragLine(touch.clientX, touch.clientY);
              event.preventDefault();
          }
      });


      window.addEventListener('touchend', (event) => {
          if (isGameOver) return;
          endDrag();
      });

      let initialPinchDistance = 0;

      renderer.domElement.addEventListener('touchstart', (event) => {
          if (event.touches.length === 2) {
              initialPinchDistance = Math.hypot(
                  event.touches[0].pageX - event.touches[1].pageX,
                  event.touches[0].pageY - event.touches[1].pageY
              );
          }
      });

      renderer.domElement.addEventListener('touchmove', (event) => {
          if (event.touches.length === 2) {
              const currentPinchDistance = Math.hypot(
                  event.touches[0].pageX - event.touches[1].pageX,
                  event.touches[0].pageY - event.touches[1].pageY
              );

              const zoomFactor = currentPinchDistance / initialPinchDistance;
              cameraOffset.multiplyScalar(1 / zoomFactor);

              const minZoom = 20;
              const maxZoom = 400;
              if (cameraOffset.length() < minZoom) {
                  cameraOffset.setLength(minZoom);
              }
              if (cameraOffset.length() > maxZoom) {
                  cameraOffset.setLength(maxZoom);
              }

              initialPinchDistance = currentPinchDistance;
          }
      });


              // Prevent context menu on right click
      renderer.domElement.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          endDrag(); // ✅ right click will also clear drag visuals
      });

      function updateConePosition() {
          // Keyboard controls
          const coneSpeed = BASE_PLAYER_SPEED * gameSpeedMultiplier;
          let keyboardMovement = new THREE.Vector2();
          if (keyState['KeyW']) keyboardMovement.y -= 1;
          if (keyState['KeyS']) keyboardMovement.y += 1;
          if (keyState['KeyA']) keyboardMovement.x -= 1;
          if (keyState['KeyD']) keyboardMovement.x += 1;

          if (keyboardMovement.length() > 0) {
              keyboardMovement.normalize();
              playerCone.position.x += keyboardMovement.x * coneSpeed;
              playerCone.position.z += keyboardMovement.y * coneSpeed;
          } else if (movementDirection.length() > 0) {
              // ✅ now moves continuously in drag direction
              playerCone.position.x += movementDirection.x * coneSpeed;
              playerCone.position.z += movementDirection.y * coneSpeed;
          }

          // Keep player within bounds
          const bounds = 980;
          playerCone.position.x = Math.max(-bounds, Math.min(bounds, playerCone.position.x));
          playerCone.position.z = Math.max(-bounds, Math.min(bounds, playerCone.position.z));
      }


              const cameraOffset = new THREE.Vector3(0, 200, 80);

              window.addEventListener('wheel', (event) => {
                  const zoomFactor = 1.1;
                  if (event.deltaY < 0) {
                      cameraOffset.multiplyScalar(1 / zoomFactor);
                  } else {
                      cameraOffset.multiplyScalar(zoomFactor);
                  }
                  const minZoom = 20;
                  const maxZoom = 400;
                  if (cameraOffset.length() < minZoom) {
                      cameraOffset.setLength(minZoom);
                  }
                  if (cameraOffset.length() > maxZoom) {
                      cameraOffset.setLength(maxZoom);
                  }
              });


              const scoreElement = document.getElementById('score');
              let score = 0;
              let level = 1;
              let experience = 0;
              let experienceToNextLevel = 5;
              const healthBarElement = document.getElementById('health-bar');
              const experienceBarElement = document.getElementById('experience-bar');
              let playerHealth = playerStats.maxHealth;
              let isPlayerHit = false;
              let hitAnimationTime = 0;
              const clock = new THREE.Clock();
              let isGameOver = false;
              let isGamePaused = false;
              const INITIAL_ENEMY_COUNT = 10;

              let gameSpeedMultiplier = 1.0;
              let playerScaleMultiplier = 1.0;
              const BASE_PLAYER_SPEED = 0.5;
              const BASE_PLAYER_RADIUS = 1.5;
              const BASE_ENEMY_PROJECTILE_SPEED = 2.0;
              const BASE_OCTAHEDRON_COOLDOWN = 2.5;

              let maxEnemies = INITIAL_ENEMY_COUNT;
              let animationId;
              let gemCounts = {
                  damage: 0,
                  speed: 0,
                  attackSpeed: 0,
                  luck: 0,
                  vacuum: 0,
                  crit: 0
              };


              function playSound(url, volume = 1.0) {
                  try {
                      const audio = new Audio(url);
                      audio.volume = volume;
                      audio.play().catch(e => console.log('Audio play failed:', e));
                  } catch (e) {
                      console.log('Audio creation failed:', e);
                  }
              }

              let lastShotTime = 0;

              // Blaster Shot variables
              const blasterShots = [];

              // Enemies
              const enemies = [];
              const skeletons = [];
              const coins = [];
              const gems = [];
              const enemyProjectiles = [];
              const beams = [];

              const coinSpriteMaterial = new THREE.SpriteMaterial({ color: 0xffd700 });
              const shooterGeometry = new THREE.TetrahedronGeometry(8);
              const shooterMaterial = new THREE.MeshStandardMaterial({ color: 0xff00ff, flatShading: true });
              const enemyProjectileGeometry = new THREE.SphereGeometry(1, 8, 8);
              const enemyProjectileMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff });

              const gemTypes = {
                  damage: { color: 0xff0000, geometry: new THREE.IcosahedronGeometry(3) },
                  speed: { color: 0x00ff00, geometry: new THREE.ConeGeometry(3, 5, 4) },
                  attackSpeed: { color: 0x800080, geometry: new THREE.OctahedronGeometry(3) },
                  luck: { color: 0xffffff, geometry: new THREE.SphereGeometry(2, 16, 16) },
                  vacuum: { color: 0x0000ff, geometry: new THREE.CylinderGeometry(2, 2, 3, 8) },
                  crit: { color: 0xffff00, geometry: new THREE.TorusGeometry(2, 0.5, 8, 16) }
              };

              function spawnEnemy() {
                  const shooterSpawnChance = level > 1 ? Math.min(0.5, score / 1000) : 0;
                  const enemyType = Math.random() < shooterSpawnChance ? 'shooter' : 'box';

                  if (enemyType === 'box') {
                      const health = 30 + Math.random() * 40 + (level * 10);
                      const maxHealth = health;

                      const enemyBaseSpeed = 0.2 + level * 0.02;
                      const speedRandomness = (Math.random() - 0.5) * 0.3;
                      const finalBaseSpeed = enemyBaseSpeed + speedRandomness;
                      const speed = finalBaseSpeed * gameSpeedMultiplier;
                      const baseSize = 10;
                      const size = baseSize - speedRandomness * 20;

                      const enemyGeometry = new THREE.BoxGeometry(size, size, size);

                      const hue = 0.1 + Math.random() * 0.8;
                      const initialColor = new THREE.Color().setHSL(hue, 1, 0.5);
                      const enemyMaterialInstance = new THREE.MeshStandardMaterial({ color: initialColor });
                      const enemyMesh = new THREE.Mesh(enemyGeometry, enemyMaterialInstance);
                      let x, z;
                      do {
                          x = (Math.random() - 0.5) * 980;
                          z = (Math.random() - 0.5) * 980;
                      } while (new THREE.Vector3(x, 5, z).distanceTo(playerCone.position) < 100);
                      enemyMesh.position.set(x, 5, z);

                      const wireframeGeometry = new THREE.WireframeGeometry(enemyGeometry);
                      const wireframeMaterial = new THREE.LineBasicMaterial({ color: initialColor });
                      const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
                      enemyMesh.add(wireframe);

                      scene.add(enemyMesh);
                      enemies.push({
                          mesh: enemyMesh,
                          speed: speed,
                          baseSpeed: finalBaseSpeed,
                          health: health,
                          maxHealth: maxHealth,
                          wireframe: wireframe,
                          type: 'box',
                          radius: size / 2,
                          initialColor: initialColor.clone()
                      });
                  } else {
                      const health = 20 + Math.random() * 20 + (level * 5);
                      const maxHealth = health;
                      const baseSpeed = 0.1 + level * 0.01;
                      const speed = baseSpeed * gameSpeedMultiplier;
                      const enemyMesh = new THREE.Mesh(shooterGeometry, shooterMaterial);
                      let x, z;
                      do {
                          x = (Math.random() - 0.5) * 480;
                          z = (Math.random() - 0.5) * 480;
                      } while (new THREE.Vector3(x, 5, z).distanceTo(playerCone.position) < 150);
                      enemyMesh.position.set(x, 5, z);

                      scene.add(enemyMesh);
                      enemies.push({
                         mesh: enemyMesh,
                          speed: speed,
                          baseSpeed: baseSpeed,
                          health: health,
                          maxHealth: maxHealth,
                          type: 'shooter',
                          lastShotTime: 0,
                          radius: 8
                      });
                  }
              }

              // Spawn initial enemies
               for (let i = 0; i < INITIAL_ENEMY_COUNT; i++) {
                   spawnEnemy();
               }

              function handleEnemyDeath(enemy) {
                  let skeletonGeometry;
                  if (enemy.type === 'box') {
                      const size = enemy.mesh.geometry.parameters.width;
                      skeletonGeometry = new THREE.BoxGeometry(size, size, size);
                  } else {
                      skeletonGeometry = new THREE.TetrahedronGeometry(8);
                  }
                  const skeletonMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true });
                  const skeleton = new THREE.Mesh(skeletonGeometry, skeletonMaterial);
                  skeleton.position.copy(enemy.mesh.position);
                  skeleton.quaternion.copy(enemy.mesh.quaternion);
                  scene.add(skeleton);
                  skeletons.push({mesh: skeleton, createdAt: Date.now()});

                  score++;
                  scoreElement.textContent = score;

                  if (Math.random() < 0.1) { // Gem drop
                      const gemTypesArray = Object.keys(gemTypes);
                      const randomGemType = gemTypesArray[Math.floor(Math.random() * gemTypesArray.length)];
                      const gemInfo = gemTypes[randomGemType];
                      const gemMaterial = new THREE.MeshStandardMaterial({ color: gemInfo.color, flatShading: true });
                      const gem = new THREE.Mesh(gemInfo.geometry, gemMaterial);
                      gem.position.copy(enemy.mesh.position);
                      gem.position.y = 2;
                      scene.add(gem);
                      gems.push({ mesh: gem, type: randomGemType });
                  } else if (Math.random() < playerStats.luck) { // Coin drop
                      const goldAmount = Math.floor(Math.random() * 5) + 1;
                      const coin = new THREE.Sprite(coinSpriteMaterial);
                      coin.scale.set(3, 3, 1);
                      coin.position.copy(enemy.mesh.position);
                      coin.position.y = 2;
                      scene.add(coin);
                      coins.push({ mesh: coin, gold: goldAmount });
                  }

                  scoreElement.classList.add('score-animated');
                  setTimeout(() => { scoreElement.classList.remove('score-animated'); }, 300);

                  scene.remove(enemy.mesh);
                  playSound('https://www.soundjay.com/misc/sounds/explosion-01.wav', 0.7);
                  spawnEnemy();
              }

              function createExplosion(position, radius) {
                  if (radius <= 0) return;
                  const explosionGeometry = new THREE.SphereGeometry(radius, 16, 16);
                  const explosionMaterial = new THREE.MeshBasicMaterial({
                      color: 0xffa500, // Orange
                      transparent: true,
                      opacity: 0.8
                  });
                  const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
                  explosion.position.copy(position);
                  scene.add(explosion);

                  const start = performance.now();
                  const duration = 300; // ms

                  function animateExplosion() {
                      const elapsed = performance.now() - start;
                      const t = elapsed / duration;

                      if (t < 1) {
                          const scale = t; // Expands from 0 to 1
                          explosion.scale.set(scale, scale, scale);
                          explosion.material.opacity = 0.8 * (1 - t); // Fades out
                          requestAnimationFrame(animateExplosion);
                      } else {
                          scene.remove(explosion);
                          explosion.geometry.dispose();
                          explosion.material.dispose();
                      }
                  }
                  animateExplosion();
              }

              let convertingGroup = null;
              let lastOctahedronSpawnTime = 0;
              const octahedronSpawnInterval = 30; // seconds

              // Animation loop
              function animate() {
                  animationId = requestAnimationFrame(animate);
                  
                  if (isGamePaused) return;
                  
                  if (isGameOver) return;

                  const delta = clock.getDelta();

                  updateConePosition();

                  // Health Regeneration
                  if (playerStats.regenRate > 0 && playerHealth < playerStats.maxHealth) {
                      playerHealth = Math.min(playerStats.maxHealth, playerHealth + playerStats.regenRate * delta);
                      healthBarElement.style.width = (playerHealth / playerStats.maxHealth) * 100 + '%';
                  }

                  // Update skeletons
                  for (let i = skeletons.length - 1; i >= 0; i--) {
                      const skeleton = skeletons[i];
                      const age = (Date.now() - skeleton.createdAt) / 1000;
                      if (age > 2) {
                          skeleton.mesh.material.opacity -= 0.05;
                          if (skeleton.mesh.material.opacity <= 0) {
                              scene.remove(skeleton.mesh);
                              skeletons.splice(i, 1);
                          }
                      }
                  }

                  // Coin and Gem pickup
                  for (let i = coins.length - 1; i >= 0; i--) {
                      const coin = coins[i];
                      const distance = playerCone.position.distanceTo(coin.mesh.position);
                      if (distance < 5) { // pickupDistance is 5
                          experience += coin.gold;
                          updateExperienceBar();
                          if (experience >= experienceToNextLevel) {
                              levelUp();
                          }
                          scene.remove(coin.mesh);
                          coins.splice(i, 1);
                          playSound('https://www.soundjay.com/misc/sounds/coin-01.wav', 0.5);                      } else if (distance < playerStats.coinPickupRadius) {
                          const direction = new THREE.Vector3().subVectors(playerCone.position, coin.mesh.position).normalize();
                          coin.mesh.position.addScaledVector(direction, 4);
                      }
                  }

                  for (let i = gems.length - 1; i >= 0; i--) {
                      const gem = gems[i];
                      const distance = playerCone.position.distanceTo(gem.mesh.position);
                      if (distance < 5) { // pickupDistance is 5
                          gemCounts[gem.type]++;
                          document.getElementById(`gem-${gem.type}`).textContent = gemCounts[gem.type];
                          scene.remove(gem.mesh);
                          gems.splice(i, 1);
                          playSound('https://www.soundjay.com/misc/sounds/coin-01.wav', 0.5);
                      } else if (distance < playerStats.pickupRadius) {
                          const direction = new THREE.Vector3().subVectors(playerCone.position, gem.mesh.position).normalize();
                          gem.mesh.position.addScaledVector(direction, 4);
                      }
                  }

                  // Update enemy positions
                  for (let i = enemies.length - 1; i >= 0; i--) {
                      const enemy = enemies[i];
                      if (enemy.type === 'box') {
                          enemy.mesh.lookAt(playerCone.position);
                          const direction = new THREE.Vector3().subVectors(playerCone.position, enemy.mesh.position).normalize();
                          enemy.mesh.position.addScaledVector(direction, enemy.speed);
                      } else if (enemy.type === 'shooter') {
                          const distanceToPlayer = enemy.mesh.position.distanceTo(playerCone.position);
                          const desiredDistanceMin = 120;
                          const desiredDistanceMax = 180;
                          const directionToPlayer = new THREE.Vector3().subVectors(playerCone.position, enemy.mesh.position).normalize();

                          // Movement
                          if (distanceToPlayer > desiredDistanceMax) {
                              // Move closer
                              const direction = new THREE.Vector3().subVectors(playerCone.position, enemy.mesh.position).normalize();
                              enemy.mesh.position.addScaledVector(direction, enemy.speed);
                          } else if (distanceToPlayer < desiredDistanceMin) {
                              // Move away
                              const direction = new THREE.Vector3().subVectors(enemy.mesh.position, playerCone.position).normalize();
                              enemy.mesh.position.addScaledVector(direction, enemy.speed);
                          } else {
                              // Strafe
                              const tangent = new THREE.Vector3(-directionToPlayer.z, 0, directionToPlayer.x).normalize();
                              enemy.mesh.position.addScaledVector(tangent, enemy.speed * 0.5);
                          }

                          enemy.mesh.lookAt(playerCone.position);


                          // Shoot at the closest target (player or active octahedron)
                          const maxRange = 180;
                          const currentTime = clock.getElapsedTime();
                          if (currentTime - enemy.lastShotTime > 2) { // 2-second cooldown
                              let targetPosition = null;
                              let minDistance = maxRange;

                              // Check player as a target
                              if (distanceToPlayer <= minDistance) {
                                  minDistance = distanceToPlayer;
                                  targetPosition = playerCone.position;
                              }

                              // Check active octahedrons as targets
                              for (const group of octahedronGroups) {
                                  if (group.state === 'active') {
                                      const distanceToOctahedron = enemy.mesh.position.distanceTo(group.octahedron.position);
                                      if (distanceToOctahedron < minDistance) {
                                          minDistance = distanceToOctahedron;
                                          targetPosition = group.octahedron.position;
                                      }
                                  }
                              }

                              // If a target was found, shoot
                              if (targetPosition) {
                                  enemy.lastShotTime = currentTime;
                                  const projectile = new THREE.Mesh(enemyProjectileGeometry, enemyProjectileMaterial);
                                  projectile.position.copy(enemy.mesh.position);
                                  const direction = new THREE.Vector3().subVectors(targetPosition, enemy.mesh.position).normalize();
                                  enemyProjectiles.push({ mesh: projectile, direction: direction, range: maxRange + 50, distanceTraveled: 0 });
                                  scene.add(projectile);
                              }
                          }
                      }

                      // Collision with octahedrons
                      for (let k = octahedronGroups.length - 1; k >= 0; k--) {
                          const group = octahedronGroups[k];
                          if (group.octahedron && enemy.mesh.position.distanceTo(group.octahedron.position) < (enemy.radius + group.radius)) {
                              group.health -= enemy.health;

                              const healthRatio = Math.max(0, group.health / group.maxHealth);
                              const color = new THREE.Color(playerConeOriginalColor).lerp(new THREE.Color(0xff0000), 1 - healthRatio);
                              group.octahedron.material.color.set(color);
                              group.octahedron.material.emissive.set(color);

                              if (group.health <= 0) {
                                  scene.remove(group.octahedron);
                                  scene.remove(group.ring);
                                  scene.remove(group.light);
                                  octahedronGroups.splice(k, 1);
                              }

                              scene.remove(enemy.mesh);
                              enemies.splice(i, 1);
                              spawnEnemy();
                              break;
                          }
                      }
                  }

                  // Update enemy projectiles
                  for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                      const projectile = enemyProjectiles[i];
                      const travelDistance = BASE_ENEMY_PROJECTILE_SPEED * gameSpeedMultiplier;
                      projectile.mesh.position.addScaledVector(projectile.direction, travelDistance);
                      projectile.distanceTraveled += travelDistance;

                      // Collision with player
                      if (projectile.mesh.position.distanceTo(playerCone.position) < playerStats.playerRadius) {
                          scene.remove(projectile.mesh);
                          enemyProjectiles.splice(i, 1);

                          if (Math.random() < playerStats.dodgeChance) {
                              // DODGE!
                              playSound('https://www.soundjay.com/misc/sounds/hit-01.wav', 0.2); // a soft 'whoosh' would be better
                          } else {
                              const damageTaken = 5 * (50 / (50 + playerStats.armor));
                              playerHealth -= damageTaken;
                              healthBarElement.style.width = (playerHealth / playerStats.maxHealth) * 100 + '%';
                              isPlayerHit = true;
                              hitAnimationTime = 0;
                              playSound('https://www.soundjay.com/misc/sounds/hit-01.wav', 0.8);
                          }
                          continue;
                      }

                      // Collision with octahedrons
                      for (let k = octahedronGroups.length - 1; k >= 0; k--) {
                          const group = octahedronGroups[k];
                          if (group.state === 'active' && projectile.mesh.position.distanceTo(group.octahedron.position) < group.radius) {
                              group.health -= 10;
                              scene.remove(projectile.mesh);
                              enemyProjectiles.splice(i, 1);
                              if (group.health <= 0) {
                                  scene.remove(group.octahedron);
                                  scene.remove(group.ring);
                                  scene.remove(group.light);
                                  octahedronGroups.splice(k, 1);
                                  playSound('https://www.soundjay.com/misc/sounds/explosion-01.wav', 1.0);
                              } else {
                                  playSound('https://www.soundjay.com/misc/sounds/hit-01.wav', 0.4);
                              }
                              break;
                          }
                      }

                      // Remove if it goes too far
                      if (projectile.distanceTraveled > projectile.range) {
                          scene.remove(projectile.mesh);
                          enemyProjectiles.splice(i, 1);
                      }
                  }

                  // Update beams
                  for (let i = beams.length - 1; i >= 0; i--) {
                      const beam = beams[i];
                      if (clock.getElapsedTime() - beam.creationTime > 0.1) { // Beam visible for 100ms
                          scene.remove(beam.mesh);
                          beams.splice(i, 1);
                      }
                  }

                  // Octahedron spawning logic
                  const currentTime = clock.getElapsedTime();
                  if (currentTime - lastOctahedronSpawnTime > octahedronSpawnInterval) {
                      lastOctahedronSpawnTime = currentTime;
                      const activeOctahedrons = octahedronGroups.filter(group => group.state !== 'idle' && group.state !== 'returning').length;
                      const spawnChance = Math.max(0, (20 - activeOctahedrons) / 20);
                      if (Math.random() < spawnChance) {
                          spawnOctahedrons(1, false);
                      }
                  }

                  // Auto-shoot at nearest enemy
                  const autoShootCurrentTime = clock.getElapsedTime();
                  const effectiveCooldown = playerStats.attackSpeed * (1 - playerStats.cooldownReduction);
                  if (autoShootCurrentTime - lastShotTime >= effectiveCooldown) {
                      let nearestEnemy = null;
                      let minDistance = Infinity;

                      for (const enemy of enemies) {
                          const distance = playerCone.position.distanceTo(enemy.mesh.position);
                          if (distance < minDistance) {
                              minDistance = distance;
                              nearestEnemy = enemy;
                          }
                      }

                      if (nearestEnemy && minDistance <= playerStats.attackDistance) {
                          lastShotTime = autoShootCurrentTime;

                          const clickedPoint = nearestEnemy.mesh.position.clone();
                          clickedPoint.y = playerCone.position.y;
                          const origin = playerCone.position.clone();
                          const direction = new THREE.Vector3().subVectors(clickedPoint, origin).normalize();
                          const extendedTargetPoint = new THREE.Vector3().copy(origin).addScaledVector(direction, 1000);

                                              const blasterGeometry = new THREE.SphereGeometry(1.5, 8, 8);
                                              const blasterMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 5 });
                          const blaster = new THREE.Mesh(blasterGeometry, blasterMaterial);
                          blaster.position.copy(playerCone.position);
                          scene.add(blaster);

                          blasterShots.push({
                              blaster,
                              targetPoint: extendedTargetPoint,
                              initialPosition: origin.clone(),
                              pierceLeft: playerStats.pierceCount,
                              hitEnemies: []
                          });
                          playSound('https://www.soundjay.com/misc/sounds/small-laser-gun-01.wav', 0.5);
                      }
                  }

                  // Collision detection between player and enemies
                  for (let i = enemies.length - 1; i >= 0; i--) {
                      const enemy = enemies[i];
                      if (playerCone.position.distanceTo(enemy.mesh.position) < (playerStats.playerRadius + enemy.radius)) {
                          if (Math.random() < playerStats.dodgeChance) {
                              // DODGE!
                              playSound('https://www.soundjay.com/misc/sounds/hit-01.wav', 0.2);
                          } else {
                              const damageTaken = 10 * (50 / (50 + playerStats.armor));
                              playerHealth -= damageTaken;
                              healthBarElement.style.width = (playerHealth / playerStats.maxHealth) * 100 + '%';
                              isPlayerHit = true;
                              hitAnimationTime = 0;
                              playSound('https://www.soundjay.com/misc/sounds/hit-01.wav', 0.8);
                          }

                          healthBarElement.parentElement.classList.add('health-bar-shaking');
                          setTimeout(() => {
                              healthBarElement.parentElement.classList.remove('health-bar-shaking');
                          }, 300);

                          scene.remove(enemy.mesh);
                          enemies.splice(i, 1);
                          spawnEnemy();
                      }
                  }

                  // Update blaster shots
                  for (let i = blasterShots.length - 1; i >= 0; i--) {
                      const shot = blasterShots[i];
                      const direction = new THREE.Vector3().subVectors(shot.targetPoint, shot.blaster.position).normalize();
                      shot.blaster.position.addScaledVector(direction, playerStats.projectileSpeed);

                      // Collision detection with enemies
                      for (let j = enemies.length - 1; j >= 0; j--) {
                          const enemy = enemies[j];
                          if (shot.blaster.position.distanceTo(enemy.mesh.position) < (shot.blaster.geometry.parameters.radius + enemy.radius) && !shot.hitEnemies.includes(enemy)) {
                              shot.pierceLeft--;
                              shot.hitEnemies.push(enemy);

                              let currentDamage = playerStats.damage;
                              if (Math.random() < playerStats.critChance) {
                                  currentDamage *= playerStats.critMultiplier;
                                  // TODO: Add visual indicator for crit
                              }

                              enemy.health -= currentDamage;

                              // Area Damage
                              if (playerStats.areaDamageRadius > 0) {
                                  createExplosion(enemy.mesh.position, playerStats.areaDamageRadius);
                                  const areaDamage = currentDamage * 0.5;
                                  for (let k = enemies.length - 1; k >= 0; k--) {
                                      const otherEnemy = enemies[k];
                                      if (otherEnemy === enemy || shot.hitEnemies.includes(otherEnemy)) continue;
                                      if (enemy.mesh.position.distanceTo(otherEnemy.mesh.position) < playerStats.areaDamageRadius + otherEnemy.radius) {
                                          otherEnemy.health -= areaDamage;
                                          if (otherEnemy.health <= 0) {
                                              // Marked for death, will be cleaned up later
                                          }
                                      }
                                  }
                              }

                              if (enemy.health > 0) {
                                  // Hit effects for non-lethal hit
                                  enemy.mesh.material.emissive = new THREE.Color(0xffffff);
                                  enemy.mesh.material.emissiveIntensity = 1;
                                  setTimeout(() => {
                                      if (enemy.mesh.material) {
                                          enemy.mesh.material.emissive = new THREE.Color(0x000000);
                                      }
                                  }, 100);
                                  playSound('https://www.soundjay.com/misc/sounds/hit-01.wav', 0.3);
                              }

                              if (shot.pierceLeft <= 0) {
                                  scene.remove(shot.blaster);
                                  blasterShots.splice(i, 1);
                                  break; // Shot is used up, exit inner loop
                              }
                          }
                      }

                      if (shot.blaster.position.distanceTo(shot.initialPosition) > 1000) {
                          scene.remove(shot.blaster);
                          blasterShots.splice(i, 1);
                          continue;
                      }
                  }


                  // Octahedron interaction
                  // Octahedron interaction
                  if (convertingGroup) {
                      const distance = playerCone.position.distanceTo(convertingGroup.ring.position);
                      if ((!keyState['Space'] || distance > 40) && convertingGroup.state !== 'active') { // 40 is a bit more than the trigger distance of 35
                          if (convertingGroup.state === 'lowering' || convertingGroup.state === 'converting') {
                              convertingGroup.state = 'returning';
                          }
                          convertingGroup = null;
                      }
                  } else {
                      let closestIdleGroup = null;
                      let minDistance = Infinity;

                      for (const group of octahedronGroups) {
                          if (group.state === 'idle' || group.state === 'returning') {
                              const distance = playerCone.position.distanceTo(group.ring.position);
                              if (distance < 35 && distance < minDistance) {
                                  minDistance = distance;
                                  closestIdleGroup = group;
                              }
                          }
                      }

                      if (closestIdleGroup) {
                          spacebarSymbol.style.display = 'block';
                          if (keyState['Space']) {
                              convertingGroup = closestIdleGroup;
                              convertingGroup.state = 'lowering';
                          }
                      } else {
                          spacebarSymbol.style.display = 'none';
                      }
                  }



                  if(convertingGroup) {
                      spacebarSymbol.classList.add('spacebar-active');
                  } else {
                      spacebarSymbol.classList.remove('spacebar-active');
                  }

                  // Update octahedron states
                  for (const group of octahedronGroups) {
                      if (group.state === 'lowering') {
                          group.animationProgress += 0.005;
                          group.animationProgress = Math.min(1, group.animationProgress);
                          group.octahedron.position.y = group.initialY - (group.initialY - 24) * group.animationProgress;

                          if (group.animationProgress >= 1) {
                              group.state = 'converting';
                          }
                      } else if (group.state === 'converting') {
                          group.conversionProgress += 0.01;
                          group.conversionProgress = Math.min(1, group.conversionProgress);

                          const newColor = new THREE.Color(0x9932CC).lerp(playerConeOriginalColor, group.conversionProgress);
                          group.octahedron.material.color.set(newColor);
                          group.octahedron.material.emissive.set(newColor);

                          if (group.conversionProgress >= 1) {
          group.state = 'active';
          convertingGroup = null;

          // ✅ Temporary flash sphere cue
          const flashGeometry = new THREE.SphereGeometry(group.radius * 1.5, 16, 16);
          const flashMaterial = new THREE.MeshBasicMaterial({
              color: 0x00ff00,
              transparent: true,
              opacity: 0.6
          });
          const flash = new THREE.Mesh(flashGeometry, flashMaterial);
          flash.position.copy(group.octahedron.position);
          scene.add(flash);

          // Animate flash shrinking & fading
          const start = performance.now();
          const duration = 500; // ms

          function animateFlash() {
              const elapsed = performance.now() - start;
              const t = elapsed / duration;

              if (t < 1) {
                  const scale = 1 + (1 - t); // shrink over time
                  flash.scale.set(scale, scale, scale);
                  flash.material.opacity = 0.6 * (1 - t);
                  requestAnimationFrame(animateFlash);
              } else {
                  scene.remove(flash);
                  flash.geometry.dispose();
                  flash.material.dispose();
              }
          }

          animateFlash();
      }



                      } else if (group.state === 'returning') {
                          group.animationProgress -= 0.01;
                          group.animationProgress = Math.max(0, group.animationProgress);
                          group.conversionProgress -= 0.01;
                          group.conversionProgress = Math.max(0, group.conversionProgress);

                          const newColor = new THREE.Color(0x9932CC).lerp(playerConeOriginalColor, group.conversionProgress);
                          group.octahedron.material.color.set(newColor);
                          group.octahedron.material.emissive.set(newColor);

                          group.octahedron.position.y = 24 + (group.initialY - 24) * (1 - group.animationProgress);

                          if (group.animationProgress <= 0) {
                              group.state = 'idle';
                          }
                      } else if (group.state === 'active') {
                          group.octahedron.position.y = 24;

                          const healthRatio = Math.max(0, group.health / group.maxHealth);
                          const color = new THREE.Color(playerConeOriginalColor).lerp(new THREE.Color(0xff0000), 1 - healthRatio);
                          group.octahedron.material.color.set(color);
                          group.octahedron.material.emissive.set(color);
                          // Turret logic from before
                          const currentTime = clock.getElapsedTime();
                          if (currentTime - group.lastShotTime > (BASE_OCTAHEDRON_COOLDOWN / gameSpeedMultiplier)) { // 0.4 shots per second
                              let nearestEnemy = null;
                              let minDistance = 200; // Max range

                              for (const enemy of enemies) {
                                  const distance = group.octahedron.position.distanceTo(enemy.mesh.position);
                                  if (distance < minDistance) {
                                      minDistance = distance;
                                      nearestEnemy = enemy;
                                  }
                              }

                              if (nearestEnemy) {
                                  group.lastShotTime = currentTime;

                                  // Start and end points
                                  const start = group.octahedron.position.clone();
                                  // Adjust start position to the bottom tip of the scaled octahedron
                                  start.y -= group.radius * group.octahedron.scale.y;
                                  const beamDirection = new THREE.Vector3().subVectors(nearestEnemy.mesh.position, start).normalize();
                                  const beamLength = 1000; // maximum beam reach
                                  const end = start.clone().addScaledVector(beamDirection, beamLength);

                                  // === Beam visual (thick green glowing cylinder) ===
                                  const beamThickness = 1.0; // Controls beam width
                                  const distance = start.distanceTo(end);
                                  const beamGeometry = new THREE.CylinderGeometry(beamThickness, beamThickness, distance, 8);
                                  const beamMaterial = new THREE.MeshBasicMaterial({
                                      color: 0x00ff00,
                                      transparent: true,
                                      opacity: 0.6,
                                      emissive: 0x00ff00,
                                      emissiveIntensity: 2
                                  });
                                  const beam = new THREE.Mesh(beamGeometry, beamMaterial);

                                  // Position and orient the cylinder to align with the beam direction
                                  beam.position.copy(start).lerp(end, 0.5);
                                  const upVector = new THREE.Vector3(0, 1, 0);
                                  beam.quaternion.setFromUnitVectors(upVector, beamDirection);

                                  scene.add(beam);
                                  beams.push({ mesh: beam, creationTime: currentTime, start, end, damage: 60 }); // Beam damage is separate for now

                                  // === Beam collision detection (segment-to-sphere) ===
                                  for (let i = enemies.length - 1; i >= 0; i--) {
                                      const enemy = enemies[i];
                                      const enemyPos = enemy.mesh.position.clone();
                                      const segDir = new THREE.Vector3().subVectors(end, start);
                                      const segLenSq = segDir.lengthSq();
                                      const t = Math.max(0, Math.min(1, enemyPos.clone().sub(start).dot(segDir) / segLenSq));
                                      const closestPoint = start.clone().addScaledVector(segDir, t);
                                      const distToBeam = enemyPos.distanceTo(closestPoint);

                                      if (distToBeam < enemy.radius) {
                                          enemy.health -= 60; // Beam damage
                                          if (enemy.health > 0) {
                                              playSound('https://www.soundjay.com/misc/sounds/hit-01.wav', 0.3);
                                          }
                                      }
                                  }

                              }
                          }
                      }
                  }

                  camera.position.copy(playerCone.position).add(cameraOffset);
                  camera.lookAt(playerCone.position);

                  if (isPlayerHit) {
                      hitAnimationTime += delta;
                      const progress = Math.sin(hitAnimationTime * Math.PI / 0.2);
                      playerCone.material.color.lerpColors(playerConeOriginalColor, new THREE.Color(0xff0000), progress);
                      playerCone.material.emissive.lerpColors(playerConeOriginalColor, new THREE.Color(0xff0000), progress);
                      if (hitAnimationTime >= 0.2) {
                          isPlayerHit = false;
                          playerCone.material.color.set(playerConeOriginalColor);
                          playerCone.material.emissive.set(playerConeOriginalColor);
                      }
                  }

                  if (playerHealth <= 0) {
                      isGameOver = true;
                      const gameOverElement = document.createElement('div');
                      gameOverElement.id = 'game-over-message';
                      gameOverElement.textContent = 'Game Over';
                      gameOverElement.style.position = 'absolute';
                      gameOverElement.style.top = '50%';
                      gameOverElement.style.left = '50%';
                      gameOverElement.style.transform = 'translate(-50%, -50%)';
                      gameOverElement.style.color = 'white';
                      gameOverElement.style.fontFamily = "'Press Start 2P', cursive";
                      gameOverElement.style.fontSize = '64px';
                      document.body.appendChild(gameOverElement);
                      playSound('https://www.soundjay.com/misc/sounds/game-over-01.wav', 1.0);

                      const resetButton = document.getElementById('reset-button');
                      if (resetButton) {
                          resetButton.style.display = 'block';
                      }
                      return;
                  }

                  for (let i = 0; i < octahedronGroups.length; i++) {
                      const group = octahedronGroups[i];
                      if (group.octahedron) {
                          const scale = 0.1 + (group.health / group.maxHealth) * 0.9;
                          group.octahedron.scale.set(scale, scale, scale);
                      }
                  }

                  // Enemy cleanup loop
                  for (let i = enemies.length - 1; i >= 0; i--) {
                      if (enemies[i].health <= 0) {
                          handleEnemyDeath(enemies[i]);
                          enemies.splice(i, 1);
                      }
                  }

                  // Ensure enough enemies are spawned based on level
                  while (enemies.length < maxEnemies) {
                      spawnEnemy();
                  }

                  renderer.render(scene, camera);
              }

              // Handle window resize
              window.addEventListener('resize', () => {
                  camera.aspect = window.innerWidth / window.innerHeight;
                  camera.updateProjectionMatrix();
                  renderer.setSize(window.innerWidth, window.innerHeight);
              }, false);

              function updateExperienceBar() {
                  const percentage = (experience / experienceToNextLevel) * 100;
                  experienceBarElement.style.width = percentage + '%';
              }

              function levelUp() {
                  level++;
                  document.getElementById('level').textContent = level;
                  experience = experience - experienceToNextLevel;
                  experienceToNextLevel = Math.floor(experienceToNextLevel * 1.2 + 5);
                  updateExperienceBar();

                  // --- Game Speed & Player Growth Scaling ---
                  const speedIncreaseFactor = Math.max(1.03, 1.15 - (level - 2) * 0.02);
                  gameSpeedMultiplier = Math.min(8.0, gameSpeedMultiplier * speedIncreaseFactor);

                  const scaleIncreaseFactor = Math.max(1.01, 1.10 - (level - 2) * 0.01);
                  playerScaleMultiplier = Math.min(4.0, playerScaleMultiplier * scaleIncreaseFactor);

                  playerCone.scale.set(playerScaleMultiplier, playerScaleMultiplier, playerScaleMultiplier);
                  playerStats.playerRadius = BASE_PLAYER_RADIUS * playerScaleMultiplier;

                  // Apply automatic damage bonus
                  playerStats.damage += 3;

                  // Update all existing enemies with the new speed
                  for (const enemy of enemies) {
                      enemy.speed = enemy.baseSpeed * gameSpeedMultiplier;
                  }

                  showLevelUpPopup();

                  // Increase max enemies with level
                  maxEnemies = INITIAL_ENEMY_COUNT + (level - 1) * 2;
              }

              const statUpgradePool = {
                  common: ['damage', 'attackSpeed', 'maxHealth', 'critChance', 'regenRate', 'armor', 'pierceCount', 'areaDamageRadius', 'luck', 'dodgeChance', 'pickupRadius', 'cooldownReduction'],
              };

              const qualityTiers = {
                  common: { color: '#9e9e9e', glow: 'rgba(158, 158, 158, 0.5)' },
                  uncommon: { color: '#4caf50', glow: 'rgba(76, 175, 80, 0.7)' },
                  rare: { color: '#2196f3', glow: 'rgba(33, 150, 243, 0.8)' },
                  epic: { color: '#9c27b0', glow: 'rgba(156, 39, 176, 0.9)' },
                  legendary: { color: '#ffc107', glow: 'rgba(255, 193, 7, 1)' },
              };

              function getQuality(normalizedValue) {
                  if (normalizedValue < 0.2) return 'common';
                  if (normalizedValue < 0.4) return 'uncommon';
                  if (normalizedValue < 0.65) return 'rare';
                  if (normalizedValue < 0.85) return 'epic';
                  return 'legendary';
              }

              function getUpgradeOptions(count) {
                  const options = [];
                  const availableStats = [...statUpgradePool.common];
                  
                  // Shuffle available stats
                  for (let i = availableStats.length - 1; i > 0; i--) {
                      const j = Math.floor(Math.random() * (i + 1));
                      [availableStats[i], availableStats[j]] = [availableStats[j], availableStats[i]];
                  }

                  for (let i = 0; i < count && i < availableStats.length; i++) {
                      const stat = availableStats[i];
                      let value, text, quality;
                      const luckFactor = Math.max(Math.random(), Math.random() + playerStats.luck - 0.5);
                      const normalizedValue = Math.min(luckFactor, 1);

                      switch (stat) {
                          case 'damage':
                              value = 3 + Math.floor(normalizedValue * 9);
                              text = `+${value} DMG`;
                              break;
                          case 'attackSpeed':
                              value = 1 - (0.05 + normalizedValue * 0.15); // 0.95 to 0.80
                              text = `+${((1/value - 1) * 100).toFixed(0)}% ASPD`;
                              break;
                          case 'maxHealth':
                              value = 5 + Math.floor(normalizedValue * 15);
                              text = `+${value} HP`;
                              break;
                          case 'critChance':
                              value = 0.01 + normalizedValue * 0.04;
                              text = `+${(value * 100).toFixed(0)}% Crit`;
                              break;
                          case 'regenRate':
                              value = 0.1 + normalizedValue * 0.4;
                              text = `+${value.toFixed(1)} HP/s`;
                              break;
                          case 'armor':
                              value = 2 + Math.floor(normalizedValue * 6);
                              text = `+${value} Armor`;
                              break;
                          case 'pierceCount':
                              value = 1 + Math.floor(normalizedValue * 1);
                              text = `+${value} Pierce`;
                              break;
                          case 'areaDamageRadius':
                              value = 5 + Math.floor(normalizedValue * 10);
                              text = `+${value} AoE`;
                              break;
                          case 'luck':
                              value = 0.02 + normalizedValue * 0.08;
                              text = `+${(value * 100).toFixed(0)}% Luck`;
                              break;
                          case 'dodgeChance':
                              value = 0.02 + normalizedValue * 0.04;
                              text = `+${(value * 100).toFixed(0)}% Dodge`;
                              break;
                          case 'pickupRadius':
                              value = 3 + Math.floor(normalizedValue * 7);
                              text = `+${value} Pickup`;
                              break;
                      }
                      quality = getQuality(normalizedValue);
                      options.push({ stat, value, text, quality });
                  }
                  return options;
              }

              let skipButtonHoldStart = 0;
              let skipButtonHoldTimer = null;
              let skipButtonAnimationId = null;
              const SKIP_HOLD_DURATION = 2000;

              function hideLevelUpPopup() {
                  document.getElementById('level-up-overlay').classList.remove('visible');
                  isGamePaused = false;
                  
                  // Cleanup skip button state
                  clearTimeout(skipButtonHoldTimer);
                  cancelAnimationFrame(skipButtonAnimationId);
                  skipButtonHoldStart = 0;
                  skipButtonHoldTimer = null;
                  skipButtonAnimationId = null;
              }

              function applyUpgrade(option) {
                  switch (option.stat) {
                      case 'damage': playerStats.damage += option.value; break;
                      case 'attackSpeed': playerStats.attackSpeed = Math.max(0.05, playerStats.attackSpeed * option.value); break;
                      case 'maxHealth': 
                          playerStats.maxHealth += option.value;
                          playerHealth += option.value;
                          break;
                      case 'critChance': playerStats.critChance = Math.min(0.75, playerStats.critChance + option.value); break;
                      case 'regenRate': playerStats.regenRate = Math.min(5.0, playerStats.regenRate + option.value); break;
                      case 'armor': playerStats.armor = Math.min(200, playerStats.armor + option.value); break;
                      case 'pierceCount': playerStats.pierceCount = Math.min(8, playerStats.pierceCount + option.value); break;
                      case 'areaDamageRadius': playerStats.areaDamageRadius = Math.min(100, playerStats.areaDamageRadius + option.value); break;
                      case 'luck': playerStats.luck = Math.min(1.5, playerStats.luck + option.value); break;
                      case 'dodgeChance': playerStats.dodgeChance = Math.min(0.6, playerStats.dodgeChance + option.value); break;
                      case 'pickupRadius': 
                          playerStats.pickupRadius += option.value;
                          playerStats.coinPickupRadius += option.value * 2;
                          break;
                  }
                  updateStatsUI();
              }

              function showLevelUpPopup() {
                  isGamePaused = true;
                  const options = getUpgradeOptions(3);
                  const optionsContainer = document.getElementById('upgrade-options');
                  optionsContainer.innerHTML = ''; // Clear previous options

                  options.forEach(option => {
                      const button = document.createElement('div');
                      button.className = 'upgrade-button';
                      const qualityInfo = qualityTiers[option.quality];
                      button.style.backgroundColor = qualityInfo.color;
                      button.style.boxShadow = `0 0 15px ${qualityInfo.glow}, 0 0 25px ${qualityInfo.glow}`;

                      button.innerHTML = `<span class="stat-name">${option.stat.toUpperCase()}</span><span class="stat-value">${option.text}</span>`;
                      
                      const onSelect = () => {
                          applyUpgrade(option);
                          hideLevelUpPopup();
                      };
                      button.addEventListener('click', onSelect);
                      button.addEventListener('touchend', (e) => { e.preventDefault(); onSelect(); });

                      optionsContainer.appendChild(button);
                  });

                  // Skip Button
                  const skipContainer = document.createElement('div');
                  skipContainer.id = 'skip-button-container';
                  const skipProgress = document.createElement('div');
                  skipProgress.id = 'skip-button-progress';
                  skipContainer.appendChild(skipProgress);
                  optionsContainer.appendChild(skipContainer);

                  function skipButtonHoldLoop() {
                      if (!skipButtonHoldStart) return;
                      const elapsed = performance.now() - skipButtonHoldStart;
                      const progress = Math.min(elapsed / SKIP_HOLD_DURATION, 1);
                      skipProgress.style.width = `${(1 - progress) * 100}%`;
                      const color = new THREE.Color(0x00ff00).lerp(new THREE.Color(0xff0000), progress);
                      skipProgress.style.backgroundColor = `#${color.getHexString()}`;
                      if (progress < 1) skipButtonAnimationId = requestAnimationFrame(skipButtonHoldLoop);
                  }

                  const startHold = (e) => {
                      e.preventDefault();
                      skipButtonHoldStart = performance.now();
                      skipButtonHoldLoop();
                      skipButtonHoldTimer = setTimeout(hideLevelUpPopup, SKIP_HOLD_DURATION);
                  };
                  const endHold = (e) => {
                      e.preventDefault();
                      clearTimeout(skipButtonHoldTimer);
                      cancelAnimationFrame(skipButtonAnimationId);
                      skipButtonHoldStart = 0;
                      skipProgress.style.width = '100%';
                      skipProgress.style.backgroundColor = '#00ff00';
                  };

                  skipContainer.addEventListener('mousedown', startHold);
                  skipContainer.addEventListener('mouseup', endHold);
                  skipContainer.addEventListener('mouseleave', endHold);
                  skipContainer.addEventListener('touchstart', startHold);
                  skipContainer.addEventListener('touchend', endHold);

                  document.getElementById('level-up-overlay').classList.add('visible');
              }

                      function resetGame() {
                  clock.start();
                  // Cancel current animation loop
                  if (animationId) {
                      cancelAnimationFrame(animationId);
                  }

                  score = 0;
                  scoreElement.textContent = score;
                  level = 1;
                  experience = 0;
                  experienceToNextLevel = 5;
                  document.getElementById('level').textContent = level;
                  updateExperienceBar();

                  // Hide level up popup if it's open
                  if (isGamePaused) hideLevelUpPopup();

                  gameSpeedMultiplier = 1.0;
                  playerScaleMultiplier = 1.0;
                  playerCone.scale.set(1, 1, 1);
                  playerStats.playerRadius = BASE_PLAYER_RADIUS;


                  gemCounts = { damage: 0, speed: 0, attackSpeed: 0, luck: 0, vacuum: 0, crit: 0 };
                  document.getElementById('gem-damage').textContent = 0;
                  document.getElementById('gem-speed').textContent = 0;
                  document.getElementById('gem-attackSpeed').textContent = 0;
                  document.getElementById('gem-luck').textContent = 0;
                  document.getElementById('gem-vacuum').textContent = 0;
                  document.getElementById('gem-crit').textContent = 0;


                  // Reset all stats to their default values
                  playerStats.attackDistance = 100;
                  playerStats.projectileSpeed = 3;
                  playerStats.damage = 30;
                  playerStats.areaDamageRadius = 0;
                  playerStats.pierceCount = 1;
                  playerStats.critChance = 0.05;
                  playerStats.maxHealth = 100;
                  playerStats.armor = 0;
                  playerStats.regenRate = 0;
                  playerStats.dodgeChance = 0;
                  playerStats.attackSpeed = 0.5;
                  playerStats.pickupRadius = 15;
                  playerStats.coinPickupRadius = 115;
                  playerStats.luck = 0.5;
                  playerStats.cooldownReduction = 0;
                  updateStatsUI();

                  lastShotTime = 0;
                  maxEnemies = INITIAL_ENEMY_COUNT;

                  playerHealth = playerStats.maxHealth;
                  healthBarElement.style.width = '100%';

                  isGameOver = false;
                  isPlayerHit = false;
                  hitAnimationTime = 0;
                  convertingGroup = null;

                  // Reset player position
                  playerCone.position.set(0, 3, 5);
                  playerCone.material.color.set(playerConeOriginalColor);
                  playerCone.material.emissive.set(playerConeOriginalColor);

                  // Clear drag visuals
                  clearDragVisuals();
                  movementDirection.set(0, 0);
                  for (let key in keyState) {
          delete keyState[key];
      }
                  isDragging = false;

                  // Remove all enemies
                  for (const enemy of enemies) {
                      scene.remove(enemy.mesh);
                  }
                  enemies.length = 0;

                  // Remove all blaster shots
                  for (const shot of blasterShots) {
                      scene.remove(shot.blaster);
                  }
                  blasterShots.length = 0;

                  // Remove all skeletons
                  for (const skeleton of skeletons) {
                      scene.remove(skeleton.mesh);
                  }
                  skeletons.length = 0;

                  // Remove all coins
                  for (const coin of coins) {
                      scene.remove(coin.mesh);
                  }
                  coins.length = 0;

                  // Remove all gems
                  for (const gem of gems) {
                      scene.remove(gem.mesh);
                  }
                  gems.length = 0;

                  // Remove all enemy projectiles
                  for (const projectile of enemyProjectiles) {
                      scene.remove(projectile.mesh);
                  }
                  enemyProjectiles.length = 0;

                  // Remove all octahedrons
                  for (const group of octahedronGroups) {
                      scene.remove(group.octahedron);
                      scene.remove(group.ring);
                      scene.remove(group.light);
                  }
                  octahedronGroups.length = 0;

                  // Re-spawn octahedrons
                  spawnOctahedrons(2, true);

                  // Remove Game Over message if it exists
                  const gameOverElement = document.getElementById('game-over-message');
                  if (gameOverElement) {
                      gameOverElement.remove();
                  }

                  // Hide reset button
                  const resetButton = document.getElementById('reset-button');
                  resetButton.style.display = 'none';

                  // Spawn initial enemies
                   for (let i = 0; i < INITIAL_ENEMY_COUNT; i++) {
                       spawnEnemy();
                   }

                  // Restart animation loop
                  animate();
              }

              const resetButton = document.getElementById('reset-button');
              resetButton.addEventListener('click', resetGame);

              // Start the game
              animate();
    </script>
  </body>
</html>
