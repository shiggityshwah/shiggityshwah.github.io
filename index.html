<!DOCTYPE html>
<html>
  <head>
    <title>3D Scene</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap");
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
      #prompt {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        font-family: sans-serif;
        font-size: 24px;
        display: none;
      }
      #score {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        font-family: "Press Start 2P", cursive;
        font-size: 72px;
      }

      @keyframes score-animation {
        0% {
          transform: translateX(-50%) scale(1);
        }
        50% {
          transform: translateX(-50%) scale(1.5);
          color: #ffc107;
        }
        100% {
          transform: translateX(-50%) scale(1);
        }
      }

      .score-animated {
        animation: score-animation 0.3s;
      }

      @keyframes health-bar-shake {
        0% {
          transform: translateX(-50%) scaleX(1);
        }
        25% {
          transform: translateX(-52%) scaleX(1.05);
        }
        50% {
          transform: translateX(-48%) scaleX(1.05);
        }
        75% {
          transform: translateX(-52%) scaleX(1.05);
        }
        100% {
          transform: translateX(-50%) scaleX(1);
        }
      }

      @keyframes spacebar-press {
        from {
          transform: translateX(-50%) scale(1);
        }
        to {
          transform: translateX(-50%) scale(0.95);
        }
      }

      .spacebar-active {
        animation: spacebar-press 0.2s forwards;
      }

      .health-bar-shaking {
        animation: health-bar-shake 0.3s;
      }

      #health-bar-container {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        width: 600px;
        height: 40px;
        border: 2px solid white;
        box-shadow: 0 0 10px white, 0 0 20px white, 0 0 30px #00bfff;
      }

      #health-bar {
        width: 100%;
        height: 100%;
        background-color: red;
        transition: width 0.2s ease;
      }

      #level-up-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(16, 16, 16, 0.85);
        display: none; /* Hidden by default */
        justify-content: center;
        align-items: center;
        z-index: 100;
        font-family: "Press Start 2P", cursive;
      }

      #level-up-popup {
        background: rgba(30, 30, 30, 0.9);
        border: 3px solid #00bfff;
        box-shadow: 0 0 20px #00bfff;
        padding: 30px;
        text-align: center;
        color: white;
        transform: scale(0);
        transition: transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        width: 90%;
        max-width: 500px;
        position: relative;
      }

      #level-up-overlay.visible {
        display: flex;
      }

      #level-up-overlay.visible #level-up-popup {
        transform: scale(1);
      }

      #level-up-popup h2 {
        color: gold;
        text-shadow: 0 0 10px gold;
        margin-top: 0;
      }

      #upgrade-options {
        position: absolute;
        bottom: 20px;
        right: 20px;
        display: flex;
        flex-direction: column;
        gap: 15px;
      }

      .upgrade-button {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        border: 3px solid white;
        color: white;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        transition: transform 0.1s, box-shadow 0.2s;
        font-size: 10px;
        padding: 5px;
        box-sizing: border-box;
      }

      .upgrade-button:hover {
        transform: scale(1.1);
      }

      .upgrade-button .stat-name {
        font-weight: bold;
      }

      .upgrade-button .stat-value {
        margin-top: 5px;
        font-size: 12px;
      }

      #skip-button-container {
        width: 80px;
        height: 30px;
        margin-top: 15px;
        border: 2px solid white;
        cursor: pointer;
        padding: 2px;
        box-sizing: border-box;
      }

      #skip-button-progress {
        width: 100%;
        height: 100%;
        background-color: #00ff00;
        transition: width 0.1s linear, background-color 0.5s linear;
      }

      #skip-button-text {
        position: absolute;
        bottom: 28px; /* Aligns with the container */
        right: 20px;
        width: 80px;
        color: white;
        font-size: 12px;
        pointer-events: none; /* Text doesn't block clicks */
      }

      #gem-counters {
        position: absolute;
        top: 90px; /* Below level */
        left: 20px;
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 5px 15px;
        font-family: "Press Start 2P", cursive;
        font-size: 14px;
        color: white;
      }
      .gem-counter {
        text-shadow: 0 0 5px black, 0 0 8px black;
      }

      #debug-info {
        position: absolute;
        top: 150px;
        left: 20px;
        color: white;
        font-family: monospace;
        background: rgba(0,0,0,0.5);
        padding: 5px;
        display: none; /* Set to 'block' to enable */
      }
    </style>
  </head>
  <body>
    <div id="score">0</div>
    <div
      id="level-container"
      style="
        position: absolute;
        top: 20px;
        left: 20px;
        color: gold;
        font-family: 'Press Start 2P', cursive;
        font-size: 60px;
      "
    >
      lvl <span id="level">1</span>
    </div>
    <div id="gem-counters">
      <span id="gem-damage" class="gem-counter" style="color: #ff0000;">0</span>
      <span id="gem-speed" class="gem-counter" style="color: #00ff00;">0</span>
      <span id="gem-attackSpeed" class="gem-counter" style="color: #800080;">0</span>
      <span id="gem-luck" class="gem-counter" style="color: #ffffff;">0</span>
      <span id="gem-vacuum" class="gem-counter" style="color: #0000ff;">0</span>
      <span id="gem-crit" class="gem-counter" style="color: #ffff00;">0</span>
    </div>
    <div id="debug-info"></div>
    <div
      id="experience-bar-container"
      style="
        position: absolute;
        bottom: 70px;
        left: 50%;
        transform: translateX(-50%);
        width: 600px;
        height: 15px;
        border: 2px solid gold;
      "
    >
      <div
        id="experience-bar"
        style="width: 0%; height: 100%; background-color: gold"
      ></div>
    </div>
    <div
      id="stats-container"
      style="
        position: absolute;
        top: 20px;
        right: 20px;
        color: white;
        font-family: 'Press Start 2P', cursive;
        font-size: 16px;
        text-align: right;
      "
    >
      <div>Attack Speed: <span id="stat-attack-speed">2.00</span></div>
      <div>Damage: <span id="stat-damage">30</span></div>
      <div>Luck: <span id="stat-luck">50</span>%</div>
      <div>Pickup Radius: <span id="stat-pickup-radius">15</span></div>
      <div>Crit Chance: <span id="stat-crit-chance">5</span>%</div>
      <div>Armor: <span id="stat-armor">0</span></div>
      <div>Regen/s: <span id="stat-regen">0.0</span></div>
      <div>Dodge: <span id="stat-dodge">0</span>%</div>
      <div>Pierce: <span id="stat-pierce">1</span></div>
      <div>AoE Radius: <span id="stat-aoe">0</span></div>
    </div>
    <div id="health-bar-container">
      <div id="health-bar"></div>
    </div>
    <div
      id="spacebar-symbol"
      style="
        position: absolute;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        display: none;
      "
    >
      <div
        style="
          height: 100px;
          background-color: white;
          border-radius: 10px;
          display: flex;
          align-items: center;
          justify-content: center;
          color: black;
          font-family: 'Press Start 2P', cursive;
          font-size: 24px;
        "
      >
      </div>
    </div>
    <button
      id="reset-button"
      style="
        position: absolute;
        top: 60%;
        left: 50%;
        transform: translateX(-50%);
        padding: 15px 30px;
        font-size: 24px;
        font-family: 'Press Start 2P', cursive;
        background-color: #00bfff;
        color: white;
        border: none;
        cursor: pointer;
        display: none;
      "
    >
      Reset Game
    </button>

    <div id="level-up-overlay">
      <div id="level-up-popup">
        <h2>LEVEL UP!</h2>
        <p>Choose an upgrade</p>
        <div id="upgrade-options">
          <!-- Buttons will be generated here -->
          <div id="skip-button-container">
            <div id="skip-button-progress"></div>
          </div>
        </div>
        <div id="skip-button-text">Skip</div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
              console.log("Script started");
              
              const LogBuffer = {
                  buffer: [],
                  maxSize: 20, // Store last 20 messages
                  originalWarn: console.warn,
                  originalError: console.error,
                  init() {
                      console.warn = (...args) => {
                          this.push('WARN', ...args);
                          this.originalWarn.apply(console, args);
                      };
                      console.error = (...args) => {
                          this.push('ERROR', ...args);
                          this.originalError.apply(console, args);
                      };
                  },
                  push(level, ...args) {
                      const message = args.map(arg => {
                          if (arg instanceof Error) {
                              return arg.stack || arg.message;
                          }
                          if (typeof arg === 'object' && arg !== null) {
                              try {
                                  return JSON.stringify(arg);
                              } catch (e) {
                                  return '[Unserializable Object]';
                              }
                          }
                          return String(arg);
                      }).join(' ');
                      this.buffer.push(`[${level}] ${new Date().toLocaleTimeString()}: ${message}`);
                      if (this.buffer.length > this.maxSize) {
                          this.buffer.shift();
                      }
                  },
                  dump() {
                      if (this.buffer.length > 0) {
                          this.originalError("\n--- Recent Log Buffer (Warnings/Errors) ---");
                          this.buffer.forEach(msg => this.originalWarn(msg)); // Use original to avoid re-buffering
                          this.originalError("-------------------------------------------\n");
                      }
                  },
                  reset() {
                      this.buffer = [];
                  }
              };
              LogBuffer.init();

              const Debug = {
                  enabled: true,
                  lastLogTime: 0,
                  logInterval: 10, // seconds
                  frameTimes: [],
                  lastSnapshot: "",
                  perf: {
                      _timings: {},
                      _order: [],
                      start(label) {
                          if (!Debug.enabled) return;
                          this._timings[label] = { start: performance.now(), duration: 0 };
                          if (!this._order.includes(label)) this._order.push(label);
                      },
                      end(label) {
                          if (!Debug.enabled || !this._timings[label]) return;
                          this._timings[label].duration = performance.now() - this._timings[label].start;
                      },
                      getResults() {
                          let resultStr = "";
                          this._order.forEach(label => {
                              if (this._timings[label] && this._timings[label].duration > 0.1) { // Only show significant timings
                                  resultStr += `${label}: ${this._timings[label].duration.toFixed(1)}ms | `;
                              }
                          });
                          return resultStr.slice(0, -2).trim(); // Remove trailing pipe and space
                      },
                      reset() {
                          this._timings = {};
                      }
                  },
                  init() {
                      this.lastLogTime = 0;
                      this.frameTimes = [];
                      this.lastSnapshot = "";
                  },
                  update(delta) {
                      if (!this.enabled) return;
                      this.frameTimes.push(delta);
                      if (delta > 0.2) {
                          console.warn(`[PERF] Stutter spike detected: Frame took ${(delta * 1000).toFixed(0)}ms`);
                      }
                      const currentTime = clock.getElapsedTime();
                      if (currentTime - this.lastLogTime > this.logInterval) {
                          this.log(currentTime);
                          this.lastLogTime = currentTime;
                      }
                  },
                  log(currentTime) {
                      if (!this.enabled || this.frameTimes.length === 0) return;
                      const avgDelta = this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length;
                      this.frameTimes = [];
                      const fps = (1 / avgDelta).toFixed(0);
                      const frameTimeMs = (avgDelta * 1000).toFixed(0);
                      const mem = renderer.info.memory;
                      const renderInfo = renderer.info.render;
                      const convertingState = convertingGroup ? convertingGroup.state : 'none';
                      const perfResults = this.perf.getResults();
                      const output = `
[DEBUG] Time: ${Math.floor(currentTime)}s | FPS: ${fps} | FrameTime: ${frameTimeMs}ms
  SceneChildren: ${scene.children.length} | Geom=${mem.geometries}, Tex=${mem.textures} | DrawCalls=${renderInfo.calls}
  Enemies: ${enemies.length}, P.Shots: ${blasterShots.length}, E.Shots: ${enemyProjectiles.length}, Skeletons: ${skeletons.length}, Beams: ${beams.length}
  Coins: ${coins.length}, Gems: ${gems.length}, Octahedrons: ${octahedronGroups.length} (Converting: ${convertingState}), Bosses: ${bossCount}
  PlayerHP: ${playerHealth.toFixed(0)}/${playerStats.maxHealth} | Score: ${score} | Level: ${level}
  Perf: [ ${perfResults} ]
`;
                      this.lastSnapshot = output;
                      console.log(output.trim());
                      renderer.info.reset();
                  },
                  logNow(prefix = "Immediate Log") {
                      const currentTime = clock.getElapsedTime();
                      const mem = renderer.info.memory;
                      const renderInfo = renderer.info.render;
                      const convertingState = convertingGroup ? convertingGroup.state : 'none';
                      const output = `
[${prefix}] Time: ${Math.floor(currentTime)}s
  SceneChildren: ${scene.children.length} | Geom=${mem.geometries}, Tex=${mem.textures} | DrawCalls=${renderInfo.calls}
  Enemies: ${enemies.length}, P.Shots: ${blasterShots.length}, E.Shots: ${enemyProjectiles.length}, Skeletons: ${skeletons.length}, Beams: ${beams.length}
  Coins: ${coins.length}, Gems: ${gems.length}, Octahedrons: ${octahedronGroups.length} (Converting: ${convertingState}), Bosses: ${bossCount}
  PlayerHP: ${playerHealth.toFixed(0)}/${playerStats.maxHealth} | Score: ${score} | Level: ${level}
  Perf: [ ${this.perf.getResults()} ]
`;
                      this.lastSnapshot = output;
                      console.log(output.trim());
                  }
              };

              const AudioManager = {
                  sounds: {},
                  init() {
                      const soundList = {
                          explosion: 'https://www.soundjay.com/misc/sounds/explosion-01.wav',
                          hit: 'https://www.soundjay.com/misc/sounds/hit-01.wav',
                          coin: 'https://www.soundjay.com/misc/sounds/coin-01.wav',
                          laser: 'https://www.soundjay.com/misc/sounds/small-laser-gun-01.wav',
                          windChime: 'https://www.soundjay.com/misc/sounds/wind-chime-01.wav',
                          gameOver: 'https://www.soundjay.com/misc/sounds/game-over-01.wav'
                      };
                      for (const name in soundList) {
                          this.sounds[name] = new Audio(soundList[name]);
                      }
                  },
                  play(name, volume = 1.0) {
                      if (this.sounds[name]) {
                          const sound = this.sounds[name].cloneNode();
                          sound.volume = volume;
                          sound.play().catch(e => {}); // Ignore play errors if context not ready
                      }
                  }
              };
              AudioManager.init();

              const ErrorWatcher = {
                  errors: {},
                  maxReports: 5,
                  report(error) {
                      const key = error.message || 'Unknown error';
                      if (!this.errors[key]) {
                          this.errors[key] = { count: 0, firstSeen: new Date(), error: error };
                      }
                      this.errors[key].count++;
                      if (this.errors[key].count <= this.maxReports) {
                          console.error("Caught error in game loop:", error);
                      } else if (this.errors[key].count === this.maxReports + 1) {
                          console.warn(`Suppressing further logs for error: "${key}". First seen at ${this.errors[key].firstSeen}.`);
                      }
                  },
                  reset() {
                      this.errors = {};
                  }
              };

              class ObjectPool {
                  constructor(createFn, size = 20) {
                      this.createFn = createFn;
                      this.inactive = [];
                      for (let i = 0; i < size; i++) {
                          this.inactive.push(this.createFn());
                      }
                  }
                  get() {
                      let obj;
                      if (this.inactive.length > 0) {
                          obj = this.inactive.pop();
                      } else {
                          // Pool is empty, create a new one as a fallback
                          obj = this.createFn();
                      }
                      scene.add(obj.mesh);
                      obj.active = true;
                      return obj;
                  }
                  release(obj) {
                      scene.remove(obj.mesh);
                      obj.active = false;
                      this.inactive.push(obj);
                  }
                  dispose() {
                      this.inactive.forEach(obj => {
                          if (obj.mesh.geometry) obj.mesh.geometry.dispose();
                          if (obj.mesh.material) {
                              if (Array.isArray(obj.mesh.material)) {
                                  obj.mesh.material.forEach(m => m.dispose());
                              } else {
                                  obj.mesh.material.dispose();
                              }
                          }
                      });
                      this.inactive = [];
                  }
              }


              class SpatialGrid {
                  constructor(width, height, cellSize) {
                      this.width = width;
                      this.height = height;
                      this.cellSize = cellSize;
                      this.gridWidth = Math.ceil(width / cellSize);
                      this.gridHeight = Math.ceil(height / cellSize);
                      this.clear();
                  }
                  getCellCoords(x, z) {
                      const gridX = Math.floor((x + this.width / 2) / this.cellSize);
                      const gridZ = Math.floor((z + this.height / 2) / this.cellSize);
                      return { gridX, gridZ };
                  }
                  getCellIndexFromCoords(gridX, gridZ) {
                      if (gridX < 0 || gridX >= this.gridWidth || gridZ < 0 || gridZ >= this.gridHeight) return -1;
                      return gridZ * this.gridWidth + gridX;
                  }
                  clear() {
                      this.grid = new Array(this.gridWidth * this.gridHeight).fill(0).map(() => []);
                  }
                  add(obj) {
                      const { gridX, gridZ } = this.getCellCoords(obj.mesh.position.x, obj.mesh.position.z);
                      const index = this.getCellIndexFromCoords(gridX, gridZ);
                      if (index !== -1) this.grid[index].push(obj);
                  }
                  getNearby(obj) { // obj is { mesh, radius }
                      const nearby = new Set();
                      const position = obj.mesh.position;
                      const radius = obj.radius || 0; // Use radius if provided, else 0
                      const { gridX, gridZ } = this.getCellCoords(position.x, position.z);
                      const cellRadius = Math.max(1, Math.ceil(radius / this.cellSize));

                      for (let dz = -cellRadius; dz <= cellRadius; dz++) {
                          for (let dx = -cellRadius; dx <= cellRadius; dx++) {
                              const checkX = gridX + dx;
                              const checkZ = gridZ + dz;
                              const index = this.getCellIndexFromCoords(checkX, checkZ);
                              if (index !== -1) {
                                  this.grid[index].forEach(item => nearby.add(item));
                              }
                          }
                      }
                      return Array.from(nearby);
                  }
              }

              class DamageNumberManager {
                  constructor(scene) {
                      this.scene = scene;
                      this.activeNumbers = [];
                      this.pool = [];
                      this.font = 'bold 24px Arial';
                      this.STACK_TIME_WINDOW = 0.3; // seconds
                      this.STACK_Y_OFFSET = 5;
                  }

                  _createPooledObject() {
                      const canvas = document.createElement('canvas');
                      canvas.width = 128;
                      canvas.height = 64;
                      const context = canvas.getContext('2d');
                      const texture = new THREE.CanvasTexture(canvas);
                      const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
                      const sprite = new THREE.Sprite(material);
                      sprite.scale.set(20, 10, 1);
                      return { sprite, canvas, context, texture };
                  }

                  _getFromPool() {
                      let obj = this.pool.pop();
                      if (!obj) {
                          obj = this._createPooledObject();
                      }
                      this.scene.add(obj.sprite);
                      return obj;
                  }

                  _releaseToPool(damageNumber) {
                      this.scene.remove(damageNumber.pooledSprite.sprite);
                      this.pool.push(damageNumber.pooledSprite);
                  }

                  create(targetObject, text, options = {}) {
                      const color = options.isHeal ? '#44FF44' : (options.isCritical ? '#FF0000' : '#FF4444');
                      const textToDisplay = options.isDodge ? 'DODGE' : (options.isHeal ? `+${text}` : String(Math.round(text)));

                      // Stacking logic using userData on the THREE.Object3D
                      const now = clock.getElapsedTime();
                      if (!targetObject.userData.lastDamageNumberTime || now - targetObject.userData.lastDamageNumberTime > this.STACK_TIME_WINDOW) {
                          targetObject.userData.damageNumberStackCount = 0;
                      } else {
                          targetObject.userData.damageNumberStackCount++;
                      }
                      targetObject.userData.lastDamageNumberTime = now;
                      const stackOffset = targetObject.userData.damageNumberStackCount * this.STACK_Y_OFFSET;

                      const pooledSprite = this._getFromPool();
                      const { sprite, canvas, context, texture } = pooledSprite;

                      context.clearRect(0, 0, canvas.width, canvas.height);
                      context.font = this.font;
                      context.fillStyle = options.isDodge ? '#FFFF00' : color;
                      context.textAlign = 'center';
                      context.textBaseline = 'middle';
                      context.strokeStyle = 'black';
                      context.lineWidth = 4;
                      context.strokeText(textToDisplay, canvas.width / 2, canvas.height / 2);
                      context.fillText(textToDisplay, canvas.width / 2, canvas.height / 2);
                      texture.needsUpdate = true;

                      const damageNumber = {
                          pooledSprite,
                          startTime: now,
                          duration: 1.0,
                          startPosition: targetObject.position.clone().add(new THREE.Vector3(0, 15 + stackOffset, 0)),
                          velocity: new THREE.Vector3((Math.random() - 0.5) * 15, 30, 0),
                          isCritical: !!options.isCritical
                      };

                      sprite.position.copy(damageNumber.startPosition);
                      this.activeNumbers.push(damageNumber);
                  }

                  update() {
                      const now = clock.getElapsedTime();
                      this.activeNumbers = this.activeNumbers.filter(num => {
                          const elapsed = now - num.startTime;
                          if (elapsed >= num.duration) {
                              this._releaseToPool(num);
                              return false;
                          }
                          const t = elapsed / num.duration;
                          const sprite = num.pooledSprite.sprite;
                          sprite.position.x = num.startPosition.x + num.velocity.x * t;
                          sprite.position.y = num.startPosition.y + num.velocity.y * t - 0.5 * 60 * t * t;
                          sprite.material.opacity = 1.0 - t * t;
                          if (num.isCritical) {
                              sprite.position.x += (Math.random() - 0.5) * 2;
                              sprite.position.y += (Math.random() - 0.5) * 2;
                          }
                          return true;
                      });
                  }
              }

              // Scene
              const scene = new THREE.Scene();
              scene.background = new THREE.Color(0x101010);

                              const ambientLight = new THREE.AmbientLight(0x9932CC, 0.3);
              scene.add(ambientLight);

              // Camera
              const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

              // Renderer
              const renderer = new THREE.WebGLRenderer({ antialias: true });
              renderer.setSize(window.innerWidth, window.innerHeight);
              renderer.shadowMap.enabled = true;
              document.body.appendChild(renderer.domElement);

              // Ground Plane
              const planeGeometry = new THREE.PlaneGeometry(2000, 2000);
              const planeMaterial = new THREE.MeshStandardMaterial({ color: 0xC2B280, side: THREE.DoubleSide, metalness: 0.2, roughness: 0.8 });
              const plane = new THREE.Mesh(planeGeometry, planeMaterial);
              plane.rotation.x = -Math.PI / 2;
              plane.receiveShadow = true;
              scene.add(plane);

              // Octahedrons
              const octahedronGroups = [];
              const octahedronGeometry = new THREE.OctahedronGeometry(24);

      function spawnOctahedrons(count = 2, nearPlayer = true) {
          const minDistance = 100;   // base spacing
          const radius = 24;         // radius of octahedrons

          for (let i = 0; i < count; i++) {
              let position;
              let tooClose;
              let attempts = 0;

              do {
                  tooClose = false;
                  if (nearPlayer) {
                      // Expanded spawn range around player
                      position = new THREE.Vector3(
                          (Math.random() - 0.5) * 400,
                          120,
                          (Math.random() - 0.5) * 400
                      );
                  } else {
                      position = new THREE.Vector3(
                          (Math.random() - 0.5) * 980,
                          120,
                          (Math.random() - 0.5) * 980
                      );
                  }

                  for (const group of octahedronGroups) {
                      const requiredSpacing = minDistance + radius * 2;
                      if (position.distanceTo(group.octahedron.position) < requiredSpacing) {
                          tooClose = true;
                          break;
                      }
                  }

                  attempts++;
                  if (attempts > 100) {
                      console.warn("Could not place octahedron after 100 attempts");
                      break;
                  }
              } while (tooClose);

              if (tooClose) { // If we broke out of the loop due to failure
                  continue;   // ...skip creating this octahedron and try the next one in the for loop.
              }

                              const octahedronMaterialInstance = new THREE.MeshStandardMaterial({ color: 0x9932CC, flatShading: true, emissive: 0x9932CC, emissiveIntensity: 0.5 });
              const octahedron = new THREE.Mesh(octahedronGeometry, octahedronMaterialInstance);
              octahedron.position.copy(position);
              octahedron.castShadow = false;
              scene.add(octahedron);

              const ring = new THREE.Mesh(
                  new THREE.RingGeometry(25, 27, 32),
                  new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 })
              );
              ring.position.set(octahedron.position.x, 0.1, octahedron.position.z);
              ring.rotation.x = -Math.PI / 2;
              scene.add(ring);

                              const light = new THREE.PointLight(0x9932CC, 2, 200);
              light.position.copy(octahedron.position); // ✅ fixed
              light.position.y += 10;                   // ✅ correct Y adjustment
              light.castShadow = false;
              scene.add(light);

              const initialY = 120;
              octahedronGroups.push({
                  octahedron,
                  ring,
                  light,
                  health: 500,
                  maxHealth: 500,
                  radius: 24,
                  state: 'idle',
                  lastShotTime: 0,
                  animationProgress: 0,
                  initialY: initialY,
                  conversionProgress: 0
              });
          }
      }


              // Call it initially
              spawnOctahedrons(2, true);

                      // Moonlight
              const moonlight = new THREE.DirectionalLight(0xC0C0C0, 0.3);
              moonlight.position.set(0, 100, 100);
              scene.add(moonlight);



                      // Player Cone
              const playerConeOriginalColor = new THREE.Color(0x00ff00);
              const playerCone = new THREE.Mesh(
                  new THREE.ConeGeometry(1.5, 6, 32),
                  new THREE.MeshStandardMaterial({ color: playerConeOriginalColor, emissive: 0x00ff00, emissiveIntensity: 1, toneMapped: false })
              );
              playerCone.position.set(0, 3, 5);
              scene.add(playerCone);

              const coneLight = new THREE.PointLight(0x00ff00, 1, 10);
              playerCone.add(coneLight);

              const playerStats = {
                  attackDistance: 100,
                  projectileSpeed: 3,
                  damage: 30,
                  areaDamageRadius: 0,
                  pierceCount: 1,
                  critChance: 0.05,
                  critMultiplier: 2,
                  maxHealth: 100,
                  armor: 0,
                  regenRate: 0,
                  dodgeChance: 0,
                  attackSpeed: 0.5, // Cooldown in seconds
                  pickupRadius: 15,
                  playerRadius: 1.5,
                  coinPickupRadius: 115,
                  luck: 0.5,
                  cooldownReduction: 0
              };

              function updateStatsUI() {
                  const effectiveCooldown = playerStats.attackSpeed * (1 - playerStats.cooldownReduction);
                  document.getElementById('stat-attack-speed').textContent = (1 / effectiveCooldown).toFixed(2);
                  document.getElementById('stat-damage').textContent = playerStats.damage;
                  document.getElementById('stat-luck').textContent = `${(playerStats.luck * 100).toFixed(0)}%`;
                  document.getElementById('stat-pickup-radius').textContent = playerStats.pickupRadius;
                  document.getElementById('stat-crit-chance').textContent = `${(playerStats.critChance * 100).toFixed(0)}%`;
                  document.getElementById('stat-armor').textContent = playerStats.armor;
                  document.getElementById('stat-regen').textContent = playerStats.regenRate.toFixed(1);
                  document.getElementById('stat-dodge').textContent = `${(playerStats.dodgeChance * 100).toFixed(0)}%`;
                  document.getElementById('stat-pierce').textContent = playerStats.pierceCount;
                  document.getElementById('stat-aoe').textContent = playerStats.areaDamageRadius;
              }

              const spacebarSymbol = document.getElementById('spacebar-symbol');

              // Change prompt text and size based on device
              const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
              const spacebarPromptDiv = spacebarSymbol.querySelector('div');
              if (isTouchDevice) {
                  spacebarPromptDiv.textContent = 'HOLD';
                  spacebarPromptDiv.style.width = '300px';
              } else {
                  spacebarPromptDiv.textContent = 'Hold SPACE';
                  spacebarPromptDiv.style.width = '400px';
              }

              spacebarSymbol.addEventListener('mousedown', () => {
                  keyState['Space'] = true;
              });

              spacebarSymbol.addEventListener('mouseup', () => {
                  keyState['Space'] = false;
              });

              spacebarSymbol.addEventListener('mouseleave', () => {
                  keyState['Space'] = false;
              });

              spacebarSymbol.addEventListener('touchstart', (event) => {
                  event.preventDefault(); // Prevent mouse events from being fired
                  keyState['Space'] = true;
              });

              spacebarSymbol.addEventListener('touchend', () => {
                  keyState['Space'] = false;
              });

              spacebarSymbol.addEventListener('touchleave', () => {
                  keyState['Space'] = false;
              });

              // Movement system
              const keyState = {};
              window.addEventListener('keydown', (e) => { keyState[e.code] = true; });
              window.addEventListener('keyup', (e) => { keyState[e.code] = false; });

              // Touch/Mouse movement system
              let isDragging = false;
              let dragStartPoint = null;
              let movementDirection = new THREE.Vector2();

              // Visual elements for drag
              let dragDot = null;
              let dragLine = null;

              function createDragVisuals(x, y) {
          // Remove existing visuals
          if (dragDot) {
              scene.remove(dragDot);
              dragDot = null;
          }
          if (dragLine) {
              scene.remove(dragLine);
              dragLine = null;
          }

          // Store drag start in screen coordinates (for joystick base)
          dragStartPoint = new THREE.Vector2(x, y);

          // Create black dot in screen space (2D overlay instead of 3D)
          dragDot = document.createElement('div');
          dragDot.style.position = 'absolute';
          dragDot.style.width = '20px';
          dragDot.style.height = '20px';
          dragDot.style.background = 'black';
          dragDot.style.borderRadius = '50%';
          dragDot.style.left = `${x - 10}px`;
          dragDot.style.top = `${y - 10}px`;
          dragDot.style.pointerEvents = 'none'; // ignore clicks
          document.body.appendChild(dragDot);
      }


              function updateDragLine(endX, endY) {
          if (!dragStartPoint) return;

          // Remove old line
          if (dragLine) {
              document.body.removeChild(dragLine);
              dragLine = null;
          }

          // Create a line in screen space (simple div for now)
          dragLine = document.createElement('div');
          dragLine.style.position = 'absolute';
          dragLine.style.background = 'white';
          dragLine.style.height = '4px';
          dragLine.style.transformOrigin = '0 50%';

          const dx = endX - dragStartPoint.x;
          const dy = endY - dragStartPoint.y;
          const length = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx) * (180 / Math.PI);

          dragLine.style.width = `${length}px`;
          dragLine.style.left = `${dragStartPoint.x}px`;
          dragLine.style.top = `${dragStartPoint.y}px`;
          dragLine.style.transform = `rotate(${angle}deg)`;

          document.body.appendChild(dragLine);

          // ✅ Update movement direction based on drag vector
          const direction = new THREE.Vector2(dx, dy);
          if (direction.length() > 10) { // threshold
              movementDirection.set(direction.x, direction.y).normalize();
              // note: -dy because screen y is inverted relative to 3D world z
          } else {
              movementDirection.set(0, 0);
          }
      }
      function endDrag() {
          if (isDragging) {
              isDragging = false;
              movementDirection.set(0, 0);
              clearDragVisuals();
          }
      }


              function clearDragVisuals() {
          if (dragDot) {
              document.body.removeChild(dragDot);
              dragDot = null;
          }
          if (dragLine) {
              document.body.removeChild(dragLine);
              dragLine = null;
          }
          dragStartPoint = null;
      }


              // Mouse events
      renderer.domElement.addEventListener('mousedown', (event) => {
          if (isGameOver) return; // ✅ ignore if game over
          if (event.button === 0) { // left click
              isDragging = true;
              createDragVisuals(event.clientX, event.clientY);
              event.preventDefault();
          }
      });


      renderer.domElement.addEventListener('mousemove', (event) => {
          if (isGameOver) return;
          if (isDragging) {
              updateDragLine(event.clientX, event.clientY);
          }
      });


      window.addEventListener('mouseup', (event) => {
          if (isGameOver) return;
          if (event.button === 0) {
              endDrag();
          }
      });


              // Touch events
      renderer.domElement.addEventListener('touchstart', (event) => {
          if (isGameOver) return;
          if (event.touches.length === 1) {
              const touch = event.touches[0];
              isDragging = true;
              createDragVisuals(touch.clientX, touch.clientY);
              event.preventDefault();
          }
      });

      renderer.domElement.addEventListener('touchmove', (event) => {
          if (isGameOver) return;
          if (isDragging && event.touches.length === 1) {
              const touch = event.touches[0];
              updateDragLine(touch.clientX, touch.clientY);
              event.preventDefault();
          }
      });


      window.addEventListener('touchend', (event) => {
          if (isGameOver) return;
          endDrag();
      });

      let initialPinchDistance = 0;

      renderer.domElement.addEventListener('touchstart', (event) => {
          if (event.touches.length === 2) {
              initialPinchDistance = Math.hypot(
                  event.touches[0].pageX - event.touches[1].pageX,
                  event.touches[0].pageY - event.touches[1].pageY
              );
          }
      });

      renderer.domElement.addEventListener('touchmove', (event) => {
          if (event.touches.length === 2) {
              const currentPinchDistance = Math.hypot(
                  event.touches[0].pageX - event.touches[1].pageX,
                  event.touches[0].pageY - event.touches[1].pageY
              );

              const zoomFactor = currentPinchDistance / initialPinchDistance;
              cameraOffset.multiplyScalar(1 / zoomFactor);

              const minZoom = 20;
              const maxZoom = 400;
              if (cameraOffset.length() < minZoom) {
                  cameraOffset.setLength(minZoom);
              }
              if (cameraOffset.length() > maxZoom) {
                  cameraOffset.setLength(maxZoom);
              }

              initialPinchDistance = currentPinchDistance;
          }
      });


              // Prevent context menu on right click
      renderer.domElement.addEventListener('contextmenu', (event) => {
          event.preventDefault();
          endDrag(); // ✅ right click will also clear drag visuals
      });

      function updateConePosition() {
          // Keyboard controls
          const coneSpeed = BASE_PLAYER_SPEED * gameSpeedMultiplier;
          let keyboardMovement = new THREE.Vector2();
          if (keyState['KeyW']) keyboardMovement.y -= 1;
          if (keyState['KeyS']) keyboardMovement.y += 1;
          if (keyState['KeyA']) keyboardMovement.x -= 1;
          if (keyState['KeyD']) keyboardMovement.x += 1;

          if (keyboardMovement.length() > 0) {
              keyboardMovement.normalize();
              playerCone.position.x += keyboardMovement.x * coneSpeed;
              playerCone.position.z += keyboardMovement.y * coneSpeed;
          } else if (movementDirection.length() > 0) {
              // ✅ now moves continuously in drag direction
              playerCone.position.x += movementDirection.x * coneSpeed;
              playerCone.position.z += movementDirection.y * coneSpeed;
          }

          // Keep player within bounds
          const bounds = 980;
          playerCone.position.x = Math.max(-bounds, Math.min(bounds, playerCone.position.x));
          playerCone.position.z = Math.max(-bounds, Math.min(bounds, playerCone.position.z));
      }


              const cameraOffset = new THREE.Vector3(0, 200, 80);

              window.addEventListener('wheel', (event) => {
                  const zoomFactor = 1.1;
                  if (event.deltaY < 0) {
                      cameraOffset.multiplyScalar(1 / zoomFactor);
                  } else {
                      cameraOffset.multiplyScalar(zoomFactor);
                  }
                  const minZoom = 20;
                  const maxZoom = 400;
                  if (cameraOffset.length() < minZoom) {
                      cameraOffset.setLength(minZoom);
                  }
                  if (cameraOffset.length() > maxZoom) {
                      cameraOffset.setLength(maxZoom);
                  }
              });


              const scoreElement = document.getElementById('score');
              let score = 0;
              let level = 1;
              let experience = 0;
              let experienceToNextLevel = 5;
              const healthBarElement = document.getElementById('health-bar');
              const experienceBarElement = document.getElementById('experience-bar');
              let playerHealth = playerStats.maxHealth;
              let isPlayerHit = false;
              let hitAnimationTime = 0;
              const clock = new THREE.Clock();
              let healthBarShakeUntil = 0;
              let isGameOver = false;
              let isGamePaused = false;
              const INITIAL_ENEMY_COUNT = 10;
              let accumulatedRegen = 0;
              let lastRegenNumberTime = 0;

              let gameSpeedMultiplier = 1.0;
              let playerScaleMultiplier = 1.0;
              const BASE_PLAYER_SPEED = 0.5;
              const BASE_PLAYER_RADIUS = 1.5;
              const BASE_ENEMY_PROJECTILE_SPEED = 2.0;
              const BASE_OCTAHEDRON_COOLDOWN = 2.5;
              const MAX_ENEMIES_TOTAL = 20;
              const MAX_BOSSES = 3;
              const MIN_BOX_RATIO = 0.6;

              const MAX_OCTAHEDRONS = 8;

              let maxEnemies = INITIAL_ENEMY_COUNT;
              let animationId;
              let gemCounts = {
                  damage: 0,
                  speed: 0,
                  attackSpeed: 0,
                  luck: 0,
                  vacuum: 0,
                  crit: 0
              };
              let enemyCounts = {};
              let bossCount = 0;
              let lastBossSpawnScore = 0;

              // --- Performance Systems ---
              let objectPools = {};
              const spatialGrid = new SpatialGrid(2000, 2000, 100);
              const damageNumberManager = new DamageNumberManager(scene);
              const MAX_PLAYER_SHOTS = 100;
              const MAX_ENEMY_SHOTS = 150;

              let lastShotTime = 0;

              // Blaster Shot variables
              const blasterShots = [];

              // Enemies
              const enemies = [];
              const skeletons = [];
              const coins = [];
              const gems = [];
              const temporaryEffects = [];
              const enemyProjectiles = [];
              const beams = [];

              const coinSpriteMaterial = new THREE.SpriteMaterial({ color: 0xffd700 });
              const shooterGeometry = new THREE.TetrahedronGeometry(8);
              const shooterMaterial = new THREE.MeshStandardMaterial({ color: 0xff00ff, flatShading: true, emissive: 0xff00ff, emissiveIntensity: 0.4 });
              const enemyProjectileGeometry = new THREE.SphereGeometry(1, 8, 8);
              const enemyProjectileMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff });

              const gemTypes = {
                  damage: { color: 0xff0000, geometry: new THREE.IcosahedronGeometry(3) },
                  speed: { color: 0x00ff00, geometry: new THREE.ConeGeometry(3, 5, 4) },
                  attackSpeed: { color: 0x800080, geometry: new THREE.OctahedronGeometry(3) },
                  luck: { color: 0xffffff, geometry: new THREE.SphereGeometry(2, 16, 16) },
                  vacuum: { color: 0x0000ff, geometry: new THREE.CylinderGeometry(2, 2, 3, 8) },
                  crit: { color: 0xffff00, geometry: new THREE.TorusGeometry(2, 0.5, 8, 16) }
              };
              
              const enemyPrototypes = {
                  box: {
                      geometry: (size) => new THREE.BoxGeometry(size, size, size),                      
                      getMaterial: () => {
                          const materialColor = new THREE.Color().setHSL(0.1 + Math.random() * 0.8, 1, 0.5);
                          return new THREE.MeshStandardMaterial({ color: materialColor, emissive: materialColor, emissiveIntensity: 0.4 });
                      },
                      baseHealth: 30, healthRand: 40, healthLevelScale: 10,
                      baseSpeed: 0.2, speedLevelScale: 0.02,
                      contactDamage: 10,
                  },
                  shooter: {
                      geometry: () => shooterGeometry, material: shooterMaterial,
                      baseHealth: 20, healthRand: 20, healthLevelScale: 5,
                      baseSpeed: 0.1, speedLevelScale: 0.01,
                      contactDamage: 10,
                  },
                  tank: {
                      geometry: () => new THREE.BoxGeometry(25, 25, 25), material: new THREE.MeshStandardMaterial({ color: 0xff4500, emissive: 0xff4500, emissiveIntensity: 0.4 }),
                      baseHealth: 120, healthRand: 80, healthLevelScale: 30,
                      baseSpeed: 0.1, speedLevelScale: 0.01,
                      contactDamage: 25,
                      specialDrop: { type: 'damage', chance: 0.5 }
                  },
                  berserker: {
                      geometry: () => new THREE.DodecahedronGeometry(6), material: new THREE.MeshStandardMaterial({ color: 0x32cd32, emissive: 0x32cd32, emissiveIntensity: 0.4 }),
                      baseHealth: 1, healthRand: 0, healthLevelScale: 0,
                      baseSpeed: 0.4, speedLevelScale: 0.04,
                      contactDamage: 5,
                      specialDrop: { type: 'speed', chance: 0.5 }
                  },
                  magnetic: {
                      geometry: () => new THREE.TorusGeometry(8, 3, 8, 16), material: new THREE.MeshStandardMaterial({ color: 0x4169e1, emissive: 0x4169e1, emissiveIntensity: 0.4 }),
                      baseHealth: 40, healthRand: 20, healthLevelScale: 8,
                      baseSpeed: 0.15, speedLevelScale: 0.015,
                      contactDamage: 10,
                      specialDrop: { type: 'vacuum', chance: 0.5 }
                  },
                  elite: {
                      geometry: () => new THREE.IcosahedronGeometry(12), material: new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffd700, emissiveIntensity: 0.6 }),
                      baseHealth: 250, healthRand: 50, healthLevelScale: 20,
                      baseSpeed: 0.18, speedLevelScale: 0.01,
                      contactDamage: 15,
                      specialDrop: { type: 'crit', chance: 0.5 }
                  },
                  phantom: {
                      geometry: () => new THREE.OctahedronGeometry(10), material: new THREE.MeshStandardMaterial({ color: 0xf0f8ff, transparent: true, opacity: 0.4, emissive: 0xf0f8ff, emissiveIntensity: 0.6 }),
                      baseHealth: 1, healthRand: 0, healthLevelScale: 0, // Takes 1 hit when vulnerable
                      baseSpeed: 0.2, speedLevelScale: 0.02,
                      contactDamage: 10,
                      specialDrop: { type: 'luck', chance: 0.5 }
                  }
              };

              function spawnSpecificEnemy(type, isBoss = false) {
                  const proto = enemyPrototypes[type];
                  if (!proto) return;

                  const health = (isBoss ? proto.baseHealth * 5 : proto.baseHealth + Math.random() * proto.healthRand + (level * proto.healthLevelScale));
                  const baseSpeed = proto.baseSpeed + level * proto.speedLevelScale;
                  const speed = baseSpeed * gameSpeedMultiplier;
                  const scale = isBoss ? 2 : 1;

                  let enemyMesh;
                  if (proto.material) {
                      enemyMesh = new THREE.Mesh(proto.geometry(), proto.material.clone());                  
                  } else {
                      const material = proto.getMaterial();
                      enemyMesh = new THREE.Mesh(proto.geometry(10 * scale), material);
                  }
                  enemyMesh.scale.set(scale, scale, scale);

                  let x, z, attempts = 0;
                  do {
                      x = (Math.random() - 0.5) * 980;
                      z = (Math.random() - 0.5) * 980;
                      if (attempts++ > 100) {
                          console.warn("Could not place enemy far from player after 100 attempts.");
                          break;
                      }
                  } while (new THREE.Vector3(x, 5 * scale, z).distanceTo(playerCone.position) < 150);
                  enemyMesh.position.set(x, 5 * scale, z);

                  const enemyData = {
                      mesh: enemyMesh,
                      speed: speed,
                      baseSpeed: baseSpeed,
                      health: health,
                      maxHealth: health,
                      type: type,
                      radius: (type === 'tank' ? 12.5 : 8) * scale,
                      contactDamage: proto.contactDamage * (isBoss ? 2 : 1),
                      isBoss: isBoss,
                  specialDrop: proto.specialDrop,
                  isGeometryShared: type === 'shooter',
                  hitEffectUntil: null,
                  baseEmissiveIntensity: enemyMesh.material.emissiveIntensity
                  };

                  if (type === 'box' || type === 'shooter' || type === 'elite' || type === 'berserker') {
                      const wireframeGeometry = new THREE.WireframeGeometry(enemyMesh.geometry);
                      const wireframeMaterial = new THREE.LineBasicMaterial({ color: enemyMesh.material.color });
                      const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
                      enemyMesh.add(wireframe);
                      enemyData.wireframe = wireframe;
                      enemyData.initialColor = enemyMesh.material.color.clone();
                  }

                  if (type === 'shooter' || type === 'elite') enemyData.lastShotTime = 0;
                  if (type === 'phantom') {
                      enemyData.teleportCount = 0;
                      enemyData.teleportsBeforeVulnerable = 3;
                      enemyData.isVulnerable = false;
                  }

                  scene.add(enemyMesh);
                  enemies.push(enemyData);
                  enemyCounts[type] = (enemyCounts[type] || 0) + 1;
                  if (isBoss) bossCount++;
              }

              function spawnBoss() {
                  if (bossCount >= MAX_BOSSES) return;
                  const bossTypes = ['tank', 'elite', 'magnetic', 'phantom'];
                  const randomBossType = bossTypes[Math.floor(Math.random() * bossTypes.length)];
                  spawnSpecificEnemy(randomBossType, true);
              }

              const enemyUnlockLevels = {
                  shooter: 2,
                  tank: 3,
                  berserker: 4,
                  magnetic: 5,
                  elite: 6,
                  phantom: 7
              };

              const spawnWeights = { shooter: 20, tank: 15, berserker: 12, magnetic: 8, elite: 5, phantom: 3 };

              function getWeightedRandomEnemyType(currentLevel) {
                  const availableTypes = [];
                  for (const type in enemyUnlockLevels) {
                      if (currentLevel >= enemyUnlockLevels[type]) {
                          availableTypes.push(type);
                      }
                  }

                  if (availableTypes.length === 0) return null;

                  const availableWeights = {};
                  let currentTotalWeight = 0;
                  for (const type of availableTypes) {
                      if (spawnWeights[type]) {
                          availableWeights[type] = spawnWeights[type];
                          currentTotalWeight += spawnWeights[type];
                      }
                  }

                  if (currentTotalWeight === 0) return availableTypes[0];

                  let rand = Math.random() * currentTotalWeight;
                  for (const type in availableWeights) {
                      if (rand < availableWeights[type]) return type;
                      rand -= availableWeights[type];
                  }
                  return availableTypes[availableTypes.length - 1]; // Fallback
              }

              function spawnEnemy() {
                  const nonBossCount = enemies.length - bossCount;
                  const boxCount = enemyCounts['box'] || 0;
                  const typeToSpawn = getWeightedRandomEnemyType(level);

                  if (typeToSpawn === null || nonBossCount === 0 || (boxCount / nonBossCount < MIN_BOX_RATIO)) {
                      spawnSpecificEnemy('box');
                  } else {
                      spawnSpecificEnemy(typeToSpawn);
                  }
              }

              // Spawn initial enemies
               for (let i = 0; i < INITIAL_ENEMY_COUNT; i++) {
                   spawnEnemy();
               }

              function handleEnemyDeath(enemy) {                  
                  // --- Add Skeleton ---
                  const skeletonGeometry = enemy.mesh.geometry; // No need to clone for wireframe
                  const skeletonMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true });
                  const skeleton = new THREE.Mesh(skeletonGeometry, skeletonMaterial);
                  skeleton.position.copy(enemy.mesh.position);
                  skeleton.quaternion.copy(enemy.mesh.quaternion);
                  skeleton.scale.copy(enemy.mesh.scale); // Important for bosses
                  scene.add(skeleton);
                  skeletons.push({mesh: skeleton, createdAt: Date.now(), isGeometryShared: enemy.isGeometryShared});

                  // --- Resource Cleanup for the original enemy ---
                  if (enemy.wireframe) {
                      enemy.mesh.remove(enemy.wireframe);
                      enemy.wireframe.geometry.dispose();
                      enemy.wireframe.material.dispose();
                  }
                  // All enemy materials are unique clones or new instances, so they can be disposed.
                  if (enemy.mesh.material) enemy.mesh.material.dispose();

                  enemyCounts[enemy.type]--;
                  if (enemy.isBoss) {
                      bossCount--;
                      // Drop a big XP coin
                      const coin = new THREE.Sprite(coinSpriteMaterial.clone());
                      coin.scale.set(6, 6, 1);
                      coin.position.copy(enemy.mesh.position);
                      coin.position.y = 2;
                      scene.add(coin);
                      coins.push({ mesh: coin, gold: 15 });

                      // Drop 2-5 gems of its type
                      const gemDropCount = 2 + Math.floor(Math.random() * 4); // 2-5 gems
                      for (let i = 0; i < gemDropCount; i++) {
                          const gemInfo = gemTypes[enemy.specialDrop.type];
                          const gem = new THREE.Mesh(gemInfo.geometry, new THREE.MeshStandardMaterial({ color: gemInfo.color, flatShading: true }));
                          gem.position.copy(enemy.mesh.position).add(new THREE.Vector3(Math.random()*10-5, 0, Math.random()*10-5));
                          gem.position.y = 2;
                          scene.add(gem);
                          gems.push({ mesh: gem, type: enemy.specialDrop.type });
                      }
                  } else {
                      // Normal enemy death
                      let didSpecialDrop = false;
                      if (enemy.specialDrop) {
                          const dropChance = enemy.specialDrop.chance * (1 + (playerStats.luck - 0.5));
                          if (Math.random() < dropChance) {
                              const gemInfo = gemTypes[enemy.specialDrop.type];
                              const gem = new THREE.Mesh(gemInfo.geometry, new THREE.MeshStandardMaterial({ color: gemInfo.color, flatShading: true }));
                              gem.position.copy(enemy.mesh.position);
                              gem.position.y = 2;
                              scene.add(gem);
                              gems.push({ mesh: gem, type: enemy.specialDrop.type });
                              didSpecialDrop = true;
                          }
                      }

                      if (!didSpecialDrop) {
                          if (Math.random() < 0.1) { // Random Gem drop
                              const gemTypesArray = Object.keys(gemTypes);
                              const randomGemType = gemTypesArray[Math.floor(Math.random() * gemTypesArray.length)];
                              const gemInfo = gemTypes[randomGemType];
                              const gem = new THREE.Mesh(gemInfo.geometry, new THREE.MeshStandardMaterial({ color: gemInfo.color, flatShading: true }));
                              gem.position.copy(enemy.mesh.position);
                              gem.position.y = 2;
                              scene.add(gem);
                              gems.push({ mesh: gem, type: randomGemType });
                          } else if (Math.random() < playerStats.luck) { // Coin drop
                              const goldAmount = Math.floor(Math.random() * 5) + 1;
                              const coin = new THREE.Sprite(coinSpriteMaterial.clone());
                              coin.scale.set(3, 3, 1);
                              coin.position.copy(enemy.mesh.position);
                              coin.position.y = 2;
                              scene.add(coin);
                              coins.push({ mesh: coin, gold: goldAmount });
                          }
                      }
                  }

                  score++;
                  scoreElement.textContent = score;

                  // Boss spawn check
                  if (score > 0 && score % 100 === 0 && score !== lastBossSpawnScore) {
                      lastBossSpawnScore = score;
                      spawnBoss();
                  }

                  scoreElement.classList.add('score-animated');
                  setTimeout(() => { scoreElement.classList.remove('score-animated'); }, 300);

                  scene.remove(enemy.mesh);
                  AudioManager.play('explosion', 0.7);
              }

              function createExplosion(position, radius) {
                  if (radius <= 0) return;
                  const explosionGeometry = new THREE.SphereGeometry(radius, 16, 16);
                  const explosionMaterial = new THREE.MeshBasicMaterial({
                      color: 0xffa500, // Orange
                      transparent: true,
                      opacity: 0.8
                  });
                  const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
                  explosion.position.copy(position);
                  scene.add(explosion);                  
                  temporaryEffects.push({
                      mesh: explosion,
                      startTime: clock.getElapsedTime(),
                      duration: 0.3, // 300ms
                      type: 'explosion'
                  });
              }

              let convertingGroup = null;
              let lastOctahedronSpawnTime = 0;
              const octahedronSpawnInterval = 30; // seconds
              let debugInterval = null;

              // Animation loop
              function animate() {
                  animationId = requestAnimationFrame(animate);
                  try {
                      if (isGamePaused) return;

                      if (isGameOver) return;

                      const delta = clock.getDelta();
                      Debug.update(delta); // Log previous frame's perf data if needed

                      Debug.perf.reset(); // Reset for current frame's measurements

                  Debug.perf.start('update_main');

                  updateConePosition();


                  // Clear spatial grid for repopulation
                  spatialGrid.clear();

                  damageNumberManager.update();
                  Debug.perf.start('update_pickups');
                  // Health Regeneration
                  if (playerStats.regenRate > 0 && playerHealth < playerStats.maxHealth) {
                      const healingThisFrame = playerStats.regenRate * delta;
                      playerHealth = Math.min(playerStats.maxHealth, playerHealth + healingThisFrame);
                      healthBarElement.style.width = (playerHealth / playerStats.maxHealth) * 100 + '%';

                      accumulatedRegen += healingThisFrame;
                      const now = clock.getElapsedTime();
                      if (now - lastRegenNumberTime > 1.0) { // Show number every 1 second
                          if (accumulatedRegen >= 1.0) {
                              damageNumberManager.create(playerCone, Math.round(accumulatedRegen), { isHeal: true });
                              accumulatedRegen = 0;
                              lastRegenNumberTime = now;
                          } else if (accumulatedRegen > 0) {
                              // Reset timer even if we don't show a number to prevent infinite accumulation on very low regen
                              lastRegenNumberTime = now;
                          }
                      }
                  }

                  // Update skeletons
                  for (let i = skeletons.length - 1; i >= 0; i--) {
                      const skeleton = skeletons[i];
                      const age = (Date.now() - skeleton.createdAt) / 1000;
                      if (age > 2) {
                          skeleton.mesh.material.opacity -= 0.05;
                          if (skeleton.mesh.material.opacity <= 0) {
                              scene.remove(skeleton.mesh);
                          if (!skeleton.isGeometryShared) {
                              skeleton.mesh.geometry.dispose();
                          }
                              skeleton.mesh.material.dispose();
                              skeletons.splice(i, 1);
                          }
                      }
                  }

                  // Coin and Gem pickup
                  for (let i = coins.length - 1; i >= 0; i--) {
                      const coin = coins[i];
                      const distance = playerCone.position.distanceTo(coin.mesh.position);
                      if (distance < 5) { // pickupDistance is 5
                          experience += coin.gold;
                          updateExperienceBar();
                          if (experience >= experienceToNextLevel) {
                              levelUp();
                          }
                          scene.remove(coin.mesh);
                          coins.splice(i, 1);
                          AudioManager.play('coin', 0.5);
                      } else if (distance < playerStats.coinPickupRadius) {
                          const direction = new THREE.Vector3().subVectors(playerCone.position, coin.mesh.position).normalize();
                          coin.mesh.position.addScaledVector(direction, 4);
                      }
                  }

                  for (let i = gems.length - 1; i >= 0; i--) {
                      const gem = gems[i];
                      const distance = playerCone.position.distanceTo(gem.mesh.position);
                      if (distance < 5) { // pickupDistance is 5
                          gemCounts[gem.type]++;
                          document.getElementById(`gem-${gem.type}`).textContent = gemCounts[gem.type];
                          scene.remove(gem.mesh);
                          gems.splice(i, 1);
                          // Gem geometry is shared, but material is unique per-instance.
                          gem.mesh.material.dispose();
                          AudioManager.play('coin', 0.5);
                      } else if (distance < playerStats.pickupRadius) {
                          const direction = new THREE.Vector3().subVectors(playerCone.position, gem.mesh.position).normalize();
                          gem.mesh.position.addScaledVector(direction, 4);
                      }
                  }
                  Debug.perf.end('update_pickups');

                  Debug.perf.start('update_enemies');
                  // Update enemy positions
                  for (let i = enemies.length - 1; i >= 0; i--) {
                      const enemy = enemies[i];

                      // If a hit flash is active and has expired, reset the flash effect
                      if (enemy.hitEffectUntil && clock.getElapsedTime() > enemy.hitEffectUntil) {
                          if (enemy.mesh.material) {
                              // Restore the emissive color from the flash (white) back to the enemy's base color
                              enemy.mesh.material.emissive.copy(enemy.mesh.material.color);
                          }
                          enemy.hitEffectUntil = null;
                      }

                      if (enemy.type === 'phantom' && enemy.isVulnerable && clock.getElapsedTime() > enemy.vulnerableUntil) {
                          enemy.isVulnerable = false;
                          enemy.teleportCount = 0;
                          enemy.mesh.material.emissive.copy(enemy.mesh.material.color);
                      }

                      // If not under a white-flash hit effect or special state, update emissive intensity based on health
                      const isPhantomVulnerable = enemy.type === 'phantom' && enemy.isVulnerable;
                      if (!enemy.hitEffectUntil && !isPhantomVulnerable && enemy.mesh.material && enemy.baseEmissiveIntensity) {
                          const healthRatio = Math.max(0, enemy.health / enemy.maxHealth);
                          enemy.mesh.material.emissiveIntensity = enemy.baseEmissiveIntensity * healthRatio;
                      }

                      if (enemy.type === 'magnetic') {
                          const pullRange = 50;
                          const pullStrength = 0.5;
                          if (enemy.mesh.position.distanceTo(playerCone.position) < pullRange) {
                              const pullDirection = new THREE.Vector3().subVectors(enemy.mesh.position, playerCone.position).normalize();
                              playerCone.position.addScaledVector(pullDirection, pullStrength);
                          }
                      }

                      if (enemy.type !== 'shooter' && enemy.type !== 'elite') {
                          enemy.mesh.lookAt(playerCone.position);
                          const direction = new THREE.Vector3().subVectors(playerCone.position, enemy.mesh.position).normalize();
                          enemy.mesh.position.addScaledVector(direction, enemy.speed);
                      } else { // Shooter and Elite logic
                          const distanceToPlayer = enemy.mesh.position.distanceTo(playerCone.position);
                          const desiredDistanceMin = 120;
                          const desiredDistanceMax = 180;
                          const directionToPlayer = new THREE.Vector3().subVectors(playerCone.position, enemy.mesh.position).normalize();

                          // Movement
                          if (distanceToPlayer > desiredDistanceMax) {
                              // Move closer
                              const direction = new THREE.Vector3().subVectors(playerCone.position, enemy.mesh.position).normalize();
                              enemy.mesh.position.addScaledVector(direction, enemy.speed);
                          } else if (distanceToPlayer < desiredDistanceMin) {
                              // Move away
                              const direction = new THREE.Vector3().subVectors(enemy.mesh.position, playerCone.position).normalize();
                              enemy.mesh.position.addScaledVector(direction, enemy.speed);
                          } else {
                              // Strafe
                              const tangent = new THREE.Vector3(-directionToPlayer.z, 0, directionToPlayer.x).normalize();
                              enemy.mesh.position.addScaledVector(tangent, enemy.speed * 0.5);
                          }

                          enemy.mesh.lookAt(playerCone.position);


                          // Shoot at the closest target (player or active octahedron)
                          const maxRange = 180;
                          const currentTime = clock.getElapsedTime(); const shootCooldown = enemy.type === 'elite' ? 3 : 2;
                          if (currentTime - enemy.lastShotTime > 2) { // 2-second cooldown
                              let targetPosition = null;
                              let minDistance = maxRange;

                              // Check player as a target
                              if (distanceToPlayer <= minDistance) {
                                  minDistance = distanceToPlayer;
                                  targetPosition = playerCone.position;
                              }

                              // Check active octahedrons as targets
                              for (const group of octahedronGroups) {
                                  if (group.state === 'active') {
                                      const distanceToOctahedron = enemy.mesh.position.distanceTo(group.octahedron.position);
                                      if (distanceToOctahedron < minDistance) {
                                          minDistance = distanceToOctahedron;
                                          targetPosition = group.octahedron.position;
                                      }
                                  }
                              }

                              // If a target was found, shoot
                              if (targetPosition) {
                                  enemy.lastShotTime = currentTime;
                                  const baseDirection = new THREE.Vector3().subVectors(targetPosition, enemy.mesh.position).normalize();

                                  const spawnProjectile = (dir) => {
                                      if (enemyProjectiles.length >= MAX_ENEMY_SHOTS) return;
                                      const projectile = objectPools.enemyProjectiles.get();
                                      projectile.mesh.position.copy(enemy.mesh.position);
                                      projectile.direction = dir;
                                      projectile.range = maxRange + 50;
                                      projectile.distanceTraveled = 0;
                                      enemyProjectiles.push(projectile);
                                  };

                                  if (enemy.type === 'elite') {
                                      const spreadAngle = Math.PI / 12; // 15 degrees
                                      spawnProjectile(baseDirection);
                                      const leftDirection = baseDirection.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), spreadAngle);
                                      spawnProjectile(leftDirection);
                                      const rightDirection = baseDirection.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), -spreadAngle);
                                      spawnProjectile(rightDirection);
                                  } else {
                                      spawnProjectile(baseDirection);
                                  }
                              }
                          }
                      }

                      // Clamp enemy Y position to keep them on the ground plane.
                      // The spawn Y is 5 * scale, which is based on half the geometry height.
                      enemy.mesh.position.y = 5 * enemy.mesh.scale.x;

                      // Add enemy to the grid AFTER its position has been updated
                      spatialGrid.add(enemy);

                      // Collision with octahedrons
                      for (let k = octahedronGroups.length - 1; k >= 0; k--) {
                          const group = octahedronGroups[k];
                          if (group.octahedron && enemy.mesh.position.distanceTo(group.octahedron.position) < (enemy.radius + group.radius)) {
                              group.health -= enemy.health;

                              const healthRatio = Math.max(0, group.health / group.maxHealth);
                              const color = new THREE.Color(playerConeOriginalColor).lerp(new THREE.Color(0xff0000), 1 - healthRatio);
                              group.octahedron.material.color.set(color);
                              group.octahedron.material.emissive.set(color);

                              if (group.health <= 0) {
                                  group.octahedron.material.dispose();
                                  group.ring.geometry.dispose();
                                  group.ring.material.dispose();
                                  scene.remove(group.octahedron);
                                  scene.remove(group.ring);
                                  scene.remove(group.light);
                                  octahedronGroups.splice(k, 1);
                              }

                              scene.remove(enemy.mesh);
                              enemies.splice(i, 1);
                              break;
                          }
                      }
                  }
                  Debug.perf.end('update_enemies');

                  Debug.perf.start('update_projectiles');

                  // Update enemy projectiles
                  for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                      const projectile = enemyProjectiles[i];
                      let projectileConsumed = false;
                      const travelDistance = BASE_ENEMY_PROJECTILE_SPEED * gameSpeedMultiplier;
                      projectile.mesh.position.addScaledVector(projectile.direction, travelDistance);
                      spatialGrid.add(projectile);
                      projectile.distanceTraveled += travelDistance;

                      // Collision with player
                      if (projectile.mesh.position.distanceTo(playerCone.position) < playerStats.playerRadius) {
                          objectPools.enemyProjectiles.release(projectile);
                          enemyProjectiles.splice(i, 1);

                          if (Math.random() < playerStats.dodgeChance) {
                              // DODGE!
                          damageNumberManager.create(playerCone, '', { isDodge: true });
                              AudioManager.play('hit', 0.2); // a soft 'whoosh' would be better
                          } else {
                              const damageTaken = 5 * (50 / (50 + playerStats.armor));
                              playerHealth -= damageTaken;
                              healthBarElement.style.width = (playerHealth / playerStats.maxHealth) * 100 + '%';
                          damageNumberManager.create(playerCone, damageTaken, {});
                              isPlayerHit = true;
                              hitAnimationTime = 0;
                              AudioManager.play('hit', 0.8);
                          }
                          continue;
                      }

                      for (let k = octahedronGroups.length - 1; k >= 0; k--) {
                          const group = octahedronGroups[k];
                          if (group.state === 'active' && projectile.mesh.position.distanceTo(group.octahedron.position) < group.radius) {
                              group.health -= 10;
                              objectPools.enemyProjectiles.release(projectile);
                              enemyProjectiles.splice(i, 1);
                              if (group.health <= 0) {
                                  group.octahedron.material.dispose();
                                  group.ring.geometry.dispose();
                                  group.ring.material.dispose();
                                  scene.remove(group.octahedron);
                                  scene.remove(group.ring);
                                  scene.remove(group.light);
                                  octahedronGroups.splice(k, 1);
                                  AudioManager.play('explosion', 1.0);
                              } else {
                                  AudioManager.play('hit', 0.4);
                              }
                              projectileConsumed = true;
                              break; // Exit the octahedron check loop.
                          }
                      }

                      if (projectileConsumed) continue;

                      // Remove if it goes too far
                      // Need to check if projectile still exists because it might have been removed by collision
                      if (projectile.active && projectile.distanceTraveled > projectile.range) {
                          objectPools.enemyProjectiles.release(projectile);
                          enemyProjectiles.splice(i, 1);
                      }
                  }

                  // Update beams
                  for (let i = beams.length - 1; i >= 0; i--) {
                      const beam = beams[i];
                      if (clock.getElapsedTime() - beam.creationTime > 0.1) { // Beam visible for 100ms
                          scene.remove(beam.mesh);
                          beam.mesh.geometry.dispose();
                          beam.mesh.material.dispose();
                          beams.splice(i, 1);
                      }
                  }
                  Debug.perf.end('update_projectiles');

                  Debug.perf.start('update_spawners');
                  // Octahedron spawning logic
                  const currentTime = clock.getElapsedTime();
                  if (currentTime - lastOctahedronSpawnTime > octahedronSpawnInterval) {
                      lastOctahedronSpawnTime = currentTime;
                      const totalOctahedrons = octahedronGroups.length;
                      const spawnChance = Math.max(0, (MAX_OCTAHEDRONS - totalOctahedrons) / MAX_OCTAHEDRONS);
                      if (Math.random() < spawnChance) {
                          spawnOctahedrons(1, false);
                      }
                  }
                  Debug.perf.end('update_spawners');

                  Debug.perf.start('update_player_shoot');
                  // Auto-shoot at nearest enemy
                  const now = clock.getElapsedTime();
                  const baseCooldown = Math.max(0.05, playerStats.attackSpeed * (1 - playerStats.cooldownReduction)); // clamp

                  if (now - lastShotTime >= baseCooldown) {                    
                    let nearest = null;
                    let bestDistance = playerStats.attackDistance;
                    
                    // --- OPTIMIZATION: Use spatial grid to find a target ---
                    const potentialTargets = spatialGrid.getNearby({
                        mesh: playerCone,
                        radius: playerStats.attackDistance
                    });

                    for (const enemy of potentialTargets) {
                      if (!enemy.health || enemy.health <= 0) continue;
                      const distance = playerCone.position.distanceTo(enemy.mesh.position);
                      if (distance < bestDistance) {
                        bestDistance = distance;
                        nearest = enemy;
                      }
                    }

                    // If we found a valid target within range
                    if (nearest) {
                      lastShotTime = now;

                      const origin = playerCone.position.clone();
                      const target = nearest.mesh.position.clone();
                      target.y = origin.y; // fire on horizontal plane
                      const dir = new THREE.Vector3().subVectors(target, origin).normalize();

                      if (blasterShots.length < MAX_PLAYER_SHOTS) {
                        const shot = objectPools.blasterShots.get();
                        shot.mesh.position.copy(origin);
                        shot.targetPoint = origin.clone().addScaledVector(dir, 1000);
                        shot.initialPosition = origin.clone();
                        shot.pierceLeft = playerStats.pierceCount;
                        shot.hitEnemies.length = 0;
                        blasterShots.push(shot);
                        AudioManager.play('laser', 0.5);
                          }
                    }
                  }
                  Debug.perf.end('update_player_shoot');

                  Debug.perf.start('update_player_collision');
                  // --- OPTIMIZATION: Use spatial grid for player-enemy collision ---
                  const nearbyToPlayer = spatialGrid.getNearby({
                      mesh: playerCone,
                      radius: playerStats.playerRadius + 30 // Check a slightly larger radius
                  });

                  for (const enemy of nearbyToPlayer) {
                      if (!enemy.health || enemy.health <= 0 || !enemy.radius) continue; // Ensure enemy is valid

                      if (playerCone.position.distanceTo(enemy.mesh.position) < (playerStats.playerRadius + enemy.radius)) {
                          if (Math.random() < playerStats.dodgeChance) {
                              damageNumberManager.create(playerCone, '', { isDodge: true });
                              continue; // Dodge
                          }

                          const damageTaken = enemy.contactDamage * (50 / (50 + playerStats.armor));
                          playerHealth -= damageTaken;
                          healthBarElement.style.width = (playerHealth / playerStats.maxHealth) * 100 + '%';
                          damageNumberManager.create(playerCone, damageTaken, {});
                          isPlayerHit = true;
                          hitAnimationTime = 0;
                          AudioManager.play('hit', 0.8);
                          healthBarElement.parentElement.classList.add('health-bar-shaking');                          
                          healthBarShakeUntil = clock.getElapsedTime() + 0.3;
                          enemy.health = 0; // Mark for death
                      }
                  }
                  Debug.perf.end('update_player_collision');

                  Debug.perf.start('update_blaster_shots');
                  // Update blaster shots
                  for (let i = blasterShots.length - 1; i >= 0; i--) {
                      const shot = blasterShots[i];
                      const direction = new THREE.Vector3().subVectors(shot.targetPoint, shot.mesh.position).normalize();
                      shot.mesh.position.addScaledVector(direction, playerStats.projectileSpeed);
                      spatialGrid.add({ mesh: shot.mesh, radius: 2 }); // Add shot to grid

                      let shotConsumed = false;
                      // Collision detection with enemies
                      const nearbyEnemies = spatialGrid.getNearby({ mesh: shot.mesh, radius: 2 });
                      for (const enemy of nearbyEnemies) {                          
                          // Guard clauses: ensure enemy is valid, alive, not already hit by this shot, and in range.
                          if (!enemy.health || enemy.health <= 0 || shot.hitEnemies.includes(enemy)) continue;

                          if (shot.mesh.position.distanceTo(enemy.mesh.position) < (shot.mesh.geometry.parameters.radius + enemy.radius)) {
                              if (enemy.type === 'phantom' && !enemy.isVulnerable) {
                                  enemy.teleportCount++;
                                  if (enemy.teleportCount >= enemy.teleportsBeforeVulnerable) {
                                      enemy.isVulnerable = true;
                                      enemy.vulnerableUntil = clock.getElapsedTime() + 2.0;
                                      enemy.mesh.material.emissive.set(0xffffff);
                                      enemy.mesh.material.emissiveIntensity = 2;
                                  } else {
                                      const angle = Math.random() * Math.PI * 2;
                                      const distance = 50 + Math.random() * 50;
                                      enemy.mesh.position.x += Math.cos(angle) * distance;
                                      enemy.mesh.position.z += Math.sin(angle) * distance;
                                  }
                                  AudioManager.play('windChime', 0.6);
                                  shot.pierceLeft = 0; // Consume shot
                              } else {
                                  shot.pierceLeft--;
                                  shot.hitEnemies.push(enemy);

                                  let currentDamage = playerStats.damage;
                                  let isCritical = false;
                                  if (Math.random() < playerStats.critChance) {
                                      currentDamage *= playerStats.critMultiplier;
                                      isCritical = true;
                                  }

                                  enemy.health -= currentDamage;
                                  damageNumberManager.create(enemy.mesh, currentDamage, { isCritical });

                                  // Area Damage
                                  if (playerStats.areaDamageRadius > 0) {
                                      createExplosion(enemy.mesh.position, playerStats.areaDamageRadius);                                  
                                      const areaDamage = currentDamage * 0.5; // AoE does 50% of primary hit damage

                                      // Use spatial grid to find victims for AoE damage - MUCH more performant
                                      const aoeVictims = spatialGrid.getNearby({
                                          mesh: { position: enemy.mesh.position }, // Query from the explosion center
                                          radius: playerStats.areaDamageRadius
                                      });

                                      for (const otherEnemy of aoeVictims) {
                                          // Skip if it's not a valid enemy, the one that triggered the explosion, or already hit by this shot
                                          if (!otherEnemy.health || otherEnemy === enemy || shot.hitEnemies.includes(otherEnemy)) continue;

                                          // Final distance check for accuracy
                                          if (enemy.mesh.position.distanceTo(otherEnemy.mesh.position) < playerStats.areaDamageRadius + otherEnemy.radius) {
                                              otherEnemy.health -= areaDamage;
                                              damageNumberManager.create(otherEnemy.mesh, areaDamage, { isCritical: false }); // AoE hits can't be crits
                                          }
                                      }
                                  }

                                  if (enemy.health > 0) {
                                      // Hit effects for non-lethal hit
                                      enemy.mesh.material.emissive.set(0xffffff);
                                      enemy.mesh.material.emissiveIntensity = 1;
                                      enemy.hitEffectUntil = clock.getElapsedTime() + 0.1;
                                      AudioManager.play('hit', 0.3);
                                  }
                              }

                              if (shot.pierceLeft <= 0) {
                                  objectPools.blasterShots.release(shot);
                                  blasterShots.splice(i, 1);
                                  shotConsumed = true;
                                  break; // Shot is used up, exit inner enemy-check loop
                              }
                          }
                      }

                      if (shotConsumed) continue; // Move to the next shot

                      // Check if shot still exists before this check
                      if (shot.active && shot.mesh.position.distanceTo(shot.initialPosition) > playerStats.attackDistance + 50) {
                          objectPools.blasterShots.release(shot);
                          blasterShots.splice(i, 1);
                          continue;
                      }
                  }
                  Debug.perf.end('update_blaster_shots');


                  Debug.perf.start('update_octahedrons');
                  // Octahedron interaction
                  // Octahedron interaction
                  if (convertingGroup) {
                      const distance = playerCone.position.distanceTo(convertingGroup.ring.position);
                      if ((!keyState['Space'] || distance > 40) && convertingGroup.state !== 'active') { // 40 is a bit more than the trigger distance of 35
                          if (convertingGroup.state === 'lowering' || convertingGroup.state === 'converting') {
                              convertingGroup.state = 'returning';
                          }
                          convertingGroup = null;
                      }
                  } else {
                      let closestIdleGroup = null;
                      let minDistance = Infinity;

                      for (const group of octahedronGroups) {
                          if (group.state === 'idle' || group.state === 'returning') {
                              const distance = playerCone.position.distanceTo(group.ring.position);
                              if (distance < 35 && distance < minDistance) {
                                  minDistance = distance;
                                  closestIdleGroup = group;
                              }
                          }
                      }

                      if (closestIdleGroup) {
                          spacebarSymbol.style.display = 'block';
                          if (keyState['Space']) {
                              convertingGroup = closestIdleGroup;
                              convertingGroup.state = 'lowering';
                          }
                      } else {
                          spacebarSymbol.style.display = 'none';
                      }
                  }



                  if(convertingGroup) {
                      spacebarSymbol.classList.add('spacebar-active');
                  } else {
                      spacebarSymbol.classList.remove('spacebar-active');
                  }

                  // Update octahedron states
                  for (const group of octahedronGroups) {
                      if (group.state === 'lowering') {
                          group.animationProgress += 0.005;
                          group.animationProgress = Math.min(1, group.animationProgress);
                          group.octahedron.position.y = group.initialY - (group.initialY - 24) * group.animationProgress;

                          if (group.animationProgress >= 1) {
                              group.state = 'converting';
                          }
                      } else if (group.state === 'converting') {
                          group.conversionProgress += 0.01;
                          group.conversionProgress = Math.min(1, group.conversionProgress);

                          const newColor = new THREE.Color(0x9932CC).lerp(playerConeOriginalColor, group.conversionProgress);
                          group.octahedron.material.color.set(newColor);
                          group.octahedron.material.emissive.set(newColor);

                          if (group.conversionProgress >= 1) {
          group.state = 'active';
          convertingGroup = null;

          // ✅ Temporary flash sphere cue
          const flashGeometry = new THREE.SphereGeometry(group.radius * 1.5, 16, 16);
          const flashMaterial = new THREE.MeshBasicMaterial({
              color: 0x00ff00,
              transparent: true,
              opacity: 0.6
          });
          const flash = new THREE.Mesh(flashGeometry, flashMaterial);
          flash.position.copy(group.octahedron.position);
          scene.add(flash);
          temporaryEffects.push({
              mesh: flash,
              startTime: clock.getElapsedTime(),
              duration: 0.5, // 500ms
              type: 'flash'
          });
      }



                      } else if (group.state === 'returning') {
                          group.animationProgress -= 0.01;
                          group.animationProgress = Math.max(0, group.animationProgress);
                          group.conversionProgress -= 0.01;
                          group.conversionProgress = Math.max(0, group.conversionProgress);

                          const newColor = new THREE.Color(0x9932CC).lerp(playerConeOriginalColor, group.conversionProgress);
                          group.octahedron.material.color.set(newColor);
                          group.octahedron.material.emissive.set(newColor);

                          group.octahedron.position.y = 24 + (group.initialY - 24) * (1 - group.animationProgress);

                          if (group.animationProgress <= 0) {
                              group.state = 'idle';
                          }
                      } else if (group.state === 'active') {
                          group.octahedron.position.y = 24;

                          const healthRatio = Math.max(0, group.health / group.maxHealth);
                          const color = new THREE.Color(playerConeOriginalColor).lerp(new THREE.Color(0xff0000), 1 - healthRatio);
                          group.octahedron.material.color.set(color);
                          group.octahedron.material.emissive.set(color);
                          // Turret logic from before
                          const currentTime = clock.getElapsedTime();
                          if (currentTime - group.lastShotTime > (BASE_OCTAHEDRON_COOLDOWN / gameSpeedMultiplier)) {
                              let nearestEnemy = null;
                              let minDistance = 200; // Max range

                              // --- OPTIMIZATION: Use spatial grid to find potential targets ---
                              const potentialTargets = spatialGrid.getNearby({
                                  mesh: { position: group.octahedron.position },
                                  radius: minDistance
                              });

                              for (const enemy of potentialTargets) {
                                  if (!enemy.health || enemy.health <= 0) continue;
                                  const distance = group.octahedron.position.distanceTo(enemy.mesh.position);
                                  if (distance < minDistance) {
                                      minDistance = distance;
                                      nearestEnemy = enemy;
                                  }
                              }

                              if (nearestEnemy) {
                                  group.lastShotTime = currentTime;

                                  // Start and end points
                                  const start = group.octahedron.position.clone();
                                  start.y -= group.radius * group.octahedron.scale.y; // Adjust to the bottom tip
                                  const beamDirection = new THREE.Vector3().subVectors(nearestEnemy.mesh.position, start).normalize();
                                  const beamLength = 1000; // maximum beam reach
                                  const end = start.clone().addScaledVector(beamDirection, beamLength);

                                  const beamThickness = 1.0; // Controls beam width
                                  const distance = start.distanceTo(end);
                                  const beamGeometry = new THREE.CylinderGeometry(beamThickness, beamThickness, distance, 8);
                                  const beamMaterial = new THREE.MeshStandardMaterial({
                                      color: 0x00ff00,
                                      emissive: 0x00ff00,
                                      emissiveIntensity: 3,
                                      transparent: true,
                                      opacity: 0.7,
                                      metalness: 0,
                                      roughness: 1
                                  });
                                  const beam = new THREE.Mesh(beamGeometry, beamMaterial);

                                  beam.position.copy(start).lerp(end, 0.5);
                                  const upVector = new THREE.Vector3(0, 1, 0);
                                  beam.quaternion.setFromUnitVectors(upVector, beamDirection);

                                  scene.add(beam);
                                  beams.push({ mesh: beam, creationTime: currentTime, start, end, damage: 60 }); // Beam damage is separate for now

                                  // --- OPTIMIZATION: Use the same potential targets for collision ---
                                  const segDir = new THREE.Vector3().subVectors(end, start);
                                  const segLenSq = segDir.lengthSq();
                                  for (const enemy of potentialTargets) {
                                      if (!enemy.health || enemy.health <= 0) continue;

                                      const enemyPos = enemy.mesh.position.clone();
                                      const t = Math.max(0, Math.min(1, enemyPos.clone().sub(start).dot(segDir) / segLenSq));
                                      const closestPoint = start.clone().addScaledVector(segDir, t);
                                      const distToBeam = enemyPos.distanceTo(closestPoint);

                                      if (distToBeam < (enemy.radius + beamThickness)) {
                                          const beamDamage = 60;
                                          enemy.health -= beamDamage; // Beam damage
                                          damageNumberManager.create(enemy.mesh, beamDamage, { isCritical: false });
                                          if (enemy.health > 0) {
                                              AudioManager.play('hit', 0.3);
                                          }
                                      }
                                  }

                              }
                          }
                      }
                  }
                  Debug.perf.end('update_octahedrons');

                  Debug.perf.start('update_effects');
                  const nowForEffects = clock.getElapsedTime(); // Use a consistent time for this block
                  for (let i = temporaryEffects.length - 1; i >= 0; i--) {
                      const effect = temporaryEffects[i];
                      const elapsed = nowForEffects - effect.startTime;
                      const t = Math.min(elapsed / effect.duration, 1.0);

                      if (t >= 1) {
                          scene.remove(effect.mesh);
                          if(effect.mesh.geometry) effect.mesh.geometry.dispose();
                          if(effect.mesh.material) effect.mesh.material.dispose();
                          temporaryEffects.splice(i, 1);
                      } else {
                          // Apply animation based on type
                          if (effect.type === 'explosion') {
                              const scale = t;
                              effect.mesh.scale.set(scale, scale, scale);
                              effect.mesh.material.opacity = 0.8 * (1 - t);
                          } else if (effect.type === 'flash') {
                              const scale = 1 + (1 - t);
                              effect.mesh.scale.set(scale, scale, scale);
                              effect.mesh.material.opacity = 0.6 * (1 - t);
                          }
                      }
                  }
                  Debug.perf.end('update_effects');


                  Debug.perf.start('update_camera_and_fx');
                  camera.position.copy(playerCone.position).add(cameraOffset);
                  camera.lookAt(playerCone.position);

                  if (isPlayerHit) {
                      hitAnimationTime += delta;
                      const progress = Math.sin(hitAnimationTime * Math.PI / 0.2);
                      playerCone.material.color.lerpColors(playerConeOriginalColor, new THREE.Color(0xff0000), progress);
                      playerCone.material.emissive.lerpColors(playerConeOriginalColor, new THREE.Color(0xff0000), progress);
                      if (hitAnimationTime >= 0.2) {
                          isPlayerHit = false;
                          playerCone.material.color.set(playerConeOriginalColor);
                          playerCone.material.emissive.set(playerConeOriginalColor);
                      }
                  }
                  
                  if (healthBarShakeUntil > 0 && clock.getElapsedTime() > healthBarShakeUntil) {
                      healthBarElement.parentElement.classList.remove('health-bar-shaking');
                      healthBarShakeUntil = 0;
                  }

                  if (playerHealth <= 0) {
                      isGameOver = true;
                      const gameOverElement = document.createElement('div');
                      gameOverElement.id = 'game-over-message';
                      gameOverElement.textContent = 'Game Over';
                      gameOverElement.style.position = 'absolute';
                      gameOverElement.style.top = '50%';
                      gameOverElement.style.left = '50%';
                      gameOverElement.style.transform = 'translate(-50%, -50%)';
                      gameOverElement.style.color = 'white';
                      gameOverElement.style.fontFamily = "'Press Start 2P', cursive";
                      gameOverElement.style.fontSize = '64px';
                      document.body.appendChild(gameOverElement);
                      AudioManager.play('gameOver', 1.0);

                      const resetButton = document.getElementById('reset-button');
                      if (resetButton) {
                          resetButton.style.display = 'block';
                      }
                      return;
                  }

                  for (let i = 0; i < octahedronGroups.length; i++) {
                      const group = octahedronGroups[i];
                      if (group.octahedron) {
                          const scale = 0.1 + (group.health / group.maxHealth) * 0.9;
                          group.octahedron.scale.set(scale, scale, scale);
                      }
                  }

                  Debug.perf.end('update_camera_and_fx');

                  Debug.perf.start('update_cleanup');
                  // Enemy cleanup loop
                  for (let i = enemies.length - 1; i >= 0; i--) {
                      if (enemies[i].health <= 0) {
                          handleEnemyDeath(enemies[i]);
                          enemies.splice(i, 1);
                      }
                  }
                  Debug.perf.end('update_cleanup');

                  Debug.perf.start('update_respawn');
                  // Ensure enough enemies are spawned based on level
                  while (enemies.length < maxEnemies) {
                      spawnEnemy();
                  }
                  Debug.perf.end('update_respawn');
                  Debug.perf.end('update_main');

                  Debug.perf.start('render');
                  renderer.render(scene, camera);
                  Debug.perf.end('render');
                  } catch (e) {
                      ErrorWatcher.report(e);
                      console.error("--- GAME PAUSED DUE TO ERROR ---");
                      Debug.logNow("ERROR SNAPSHOT");
                      LogBuffer.dump();
                      console.error("Full error object:", e);
                      // To prevent the game from freezing in a broken state, we can pause it.
                      isGamePaused = true;
                  }
              }

              // Handle window resize
              window.addEventListener('resize', () => {
                  camera.aspect = window.innerWidth / window.innerHeight;
                  camera.updateProjectionMatrix();
                  renderer.setSize(window.innerWidth, window.innerHeight);
              }, false);

              function updateExperienceBar() {
                  const percentage = (experience / experienceToNextLevel) * 100;
                  experienceBarElement.style.width = percentage + '%';
              }

              function levelUp() {
                  level++;
                  document.getElementById('level').textContent = level;
                  experience = experience - experienceToNextLevel;
                  experienceToNextLevel = Math.floor(experienceToNextLevel * 1.2 + 5);
                  updateExperienceBar();

                  // --- Game Speed & Player Growth Scaling ---
                  const speedIncreaseFactor = Math.max(1.03, 1.15 - (level - 2) * 0.02);
                  gameSpeedMultiplier = Math.min(8.0, gameSpeedMultiplier * speedIncreaseFactor);

                  const scaleIncreaseFactor = Math.max(1.01, 1.10 - (level - 2) * 0.01);
                  playerScaleMultiplier = Math.min(4.0, playerScaleMultiplier * scaleIncreaseFactor);

                  playerCone.scale.set(playerScaleMultiplier, playerScaleMultiplier, playerScaleMultiplier);
                  playerStats.playerRadius = BASE_PLAYER_RADIUS * playerScaleMultiplier;

                  // Apply automatic damage bonus
                  playerStats.damage += 3;

                  // Update all existing enemies with the new speed
                  for (const enemy of enemies) {
                      enemy.speed = enemy.baseSpeed * gameSpeedMultiplier;
                  }

                  showLevelUpPopup();

                  // Increase max enemies with level
                  maxEnemies = Math.min(MAX_ENEMIES_TOTAL, INITIAL_ENEMY_COUNT + (level - 1) * 2);
              }

              const statUpgradePool = {
                  common: ['damage', 'attackSpeed', 'maxHealth', 'critChance', 'regenRate', 'armor', 'pierceCount', 'areaDamageRadius', 'luck', 'dodgeChance', 'pickupRadius', 'cooldownReduction']
              };

              const qualityTiers = {
                  common:   { color: '#9e9e9e', boxShadow: 'none' },
                  uncommon: { color: '#4caf50', boxShadow: 'none' },
                  rare:     { color: '#2196f3', boxShadow: '0 0 12px rgba(33, 150, 243, 0.7)' },
                  epic:     { color: '#9c27b0', boxShadow: '0 0 18px rgba(156, 39, 176, 0.9), 0 0 8px rgba(156, 39, 176, 0.9)' },
                  legendary:{ color: '#ffc107', boxShadow: '0 0 25px rgba(255, 193, 7, 1), 0 0 12px rgba(255, 193, 7, 1)' }
              };

              function getQuality(normalizedValue) {
                  if (normalizedValue < 0.2) return 'common';
                  if (normalizedValue < 0.4) return 'uncommon';
                  if (normalizedValue < 0.65) return 'rare';
                  if (normalizedValue < 0.85) return 'epic';
                  return 'legendary';
              }

              function getUpgradeOptions(count) {
                  const options = [];
                  const availableStats = [...statUpgradePool.common];
                  
                  // Shuffle available stats
                  for (let i = availableStats.length - 1; i > 0; i--) {
                      const j = Math.floor(Math.random() * (i + 1));
                      [availableStats[i], availableStats[j]] = [availableStats[j], availableStats[i]];
                  }

                  for (let i = 0; i < count && i < availableStats.length; i++) {
                      const stat = availableStats[i];
                      let value, text, quality;
                      const luckFactor = Math.max(Math.random(), Math.random() + playerStats.luck - 0.5);
                      const normalizedValue = Math.min(luckFactor, 1);

                      switch (stat) {
                          case 'damage':
                              value = 3 + Math.floor(normalizedValue * 9);
                              text = `+${value} DMG`;
                              break;
                          case 'attackSpeed':
                              value = 1 - (0.05 + normalizedValue * 0.15); // 0.95 to 0.80
                              text = `+${((1/value - 1) * 100).toFixed(0)}% ASPD`;
                              break;
                          case 'maxHealth':
                              value = 5 + Math.floor(normalizedValue * 15);
                              text = `+${value} HP`;
                              break;
                          case 'critChance':
                              value = 0.01 + normalizedValue * 0.04;
                              text = `+${(value * 100).toFixed(0)}% Crit`;
                              break;
                          case 'regenRate':
                              value = 0.1 + normalizedValue * 0.4;
                              text = `+${value.toFixed(1)} HP/s`;
                              break;
                          case 'armor':
                              value = 2 + Math.floor(normalizedValue * 6);
                              text = `+${value} Armor`;
                              break;
                          case 'pierceCount':
                              value = 1 + Math.floor(normalizedValue * 1);
                              text = `+${value} Pierce`;
                              break;
                          case 'areaDamageRadius':
                              value = 5 + Math.floor(normalizedValue * 10);
                              text = `+${value} AoE`;
                              break;
                          case 'luck':
                              value = 0.02 + normalizedValue * 0.08;
                              text = `+${(value * 100).toFixed(0)}% Luck`;
                              break;
                          case 'dodgeChance':
                              value = 0.02 + normalizedValue * 0.04;
                              text = `+${(value * 100).toFixed(0)}% Dodge`;
                              break;
                          case 'pickupRadius':
                              value = 3 + Math.floor(normalizedValue * 7);
                              text = `+${value} Pickup`;
                              break;
                      }
                      quality = getQuality(normalizedValue);
                      options.push({ stat, value, text, quality });
                  }
                  return options;
              }

              let skipButtonHoldStart = 0;
              let skipButtonHoldTimer = null;
              let skipButtonAnimationId = null;
              const SKIP_HOLD_DURATION = 2000;

              function hideLevelUpPopup() {
                  document.getElementById('level-up-overlay').classList.remove('visible');
                  isGamePaused = false;
                  
                  // Cleanup skip button state
                  clearTimeout(skipButtonHoldTimer);
                  cancelAnimationFrame(skipButtonAnimationId);
                  skipButtonHoldStart = 0;
                  skipButtonHoldTimer = null;
                  skipButtonAnimationId = null;
              }

              function applyUpgrade(option) {
                  switch (option.stat) {
                      case 'damage': playerStats.damage += option.value; break;
                      case 'attackSpeed': playerStats.attackSpeed = Math.max(0.05, playerStats.attackSpeed * option.value); break;
                      case 'maxHealth': 
                          playerStats.maxHealth += option.value;
                          damageNumberManager.create(playerCone, option.value, { isHeal: true });
                          playerHealth += option.value;
                          break;
                      case 'critChance': playerStats.critChance = Math.min(0.75, playerStats.critChance + option.value); break;
                      case 'regenRate': playerStats.regenRate = Math.min(5.0, playerStats.regenRate + option.value); break;
                      case 'armor': playerStats.armor = Math.min(200, playerStats.armor + option.value); break;
                      case 'pierceCount': playerStats.pierceCount = Math.min(8, playerStats.pierceCount + option.value); break;
                      case 'areaDamageRadius': playerStats.areaDamageRadius = Math.min(100, playerStats.areaDamageRadius + option.value); break;
                      case 'luck': playerStats.luck = Math.min(1.5, playerStats.luck + option.value); break;
                      case 'dodgeChance': playerStats.dodgeChance = Math.min(0.6, playerStats.dodgeChance + option.value); break;
                      case 'pickupRadius': 
                          playerStats.pickupRadius += option.value;
                          playerStats.coinPickupRadius += option.value * 2;
                          break;
                  }
                  updateStatsUI();
              }

              function showLevelUpPopup() {
                  isGamePaused = true;
                  const options = getUpgradeOptions(3);
                  const optionsContainer = document.getElementById('upgrade-options');
                  optionsContainer.innerHTML = ''; // Clear previous options

                  options.forEach(option => {
                      const button = document.createElement('div');
                      button.className = 'upgrade-button';
                      const qualityInfo = qualityTiers[option.quality];
                      button.style.backgroundColor = qualityInfo.color;
                      button.style.boxShadow = qualityInfo.boxShadow;

                      button.innerHTML = `<span class="stat-name">${option.stat.toUpperCase()}</span><span class="stat-value">${option.text}</span>`;
                      
                      const onSelect = () => {
                          applyUpgrade(option);
                          hideLevelUpPopup();
                      };
                      button.addEventListener('click', onSelect);
                      button.addEventListener('touchend', (e) => { e.preventDefault(); onSelect(); });

                      optionsContainer.appendChild(button);
                  });

                  // Skip Button
                  const skipContainer = document.createElement('div');
                  skipContainer.id = 'skip-button-container';
                  const skipProgress = document.createElement('div');
                  skipProgress.id = 'skip-button-progress';
                  skipContainer.appendChild(skipProgress);
                  optionsContainer.appendChild(skipContainer);

                  function skipButtonHoldLoop() {
                      if (!skipButtonHoldStart) return;
                      const elapsed = performance.now() - skipButtonHoldStart;
                      const progress = Math.min(elapsed / SKIP_HOLD_DURATION, 1);
                      skipProgress.style.width = `${(1 - progress) * 100}%`;
                      const color = new THREE.Color(0x00ff00).lerp(new THREE.Color(0xff0000), progress);
                      skipProgress.style.backgroundColor = `#${color.getHexString()}`;
                      if (progress < 1) skipButtonAnimationId = requestAnimationFrame(skipButtonHoldLoop);
                  }

                  const startHold = (e) => {
                      e.preventDefault();
                      skipButtonHoldStart = performance.now();
                      skipButtonHoldLoop();
                      skipButtonHoldTimer = setTimeout(hideLevelUpPopup, SKIP_HOLD_DURATION);
                  };
                  const endHold = (e) => {
                      e.preventDefault();
                      clearTimeout(skipButtonHoldTimer);
                      cancelAnimationFrame(skipButtonAnimationId);
                      skipButtonHoldStart = 0;
                      skipProgress.style.width = '100%';
                      skipProgress.style.backgroundColor = '#00ff00';
                  };

                  skipContainer.addEventListener('mousedown', startHold);
                  skipContainer.addEventListener('mouseup', endHold);
                  skipContainer.addEventListener('mouseleave', endHold);
                  skipContainer.addEventListener('touchstart', startHold);
                  skipContainer.addEventListener('touchend', endHold);

                  document.getElementById('level-up-overlay').classList.add('visible');
              }

              function resetGame() {
                  Debug.init();
                  ErrorWatcher.reset();
                  LogBuffer.reset();
                  clock.start();
                  // Cancel current animation loop
                  if (animationId) {
                      cancelAnimationFrame(animationId);
                  }
                  // Clear any existing debug interval
                  if (debugInterval) {
                      clearInterval(debugInterval);
                  }

                  score = 0;
                  scoreElement.textContent = score;
                  level = 1;
                  experience = 0;
                  experienceToNextLevel = 5;
                  document.getElementById('level').textContent = level;
                  updateExperienceBar();

                  // Clear and re-initialize pools
                  if (objectPools.blasterShots) objectPools.blasterShots.dispose();
                  if (objectPools.enemyProjectiles) objectPools.enemyProjectiles.dispose();

                  objectPools.blasterShots = new ObjectPool(() => {
                      const blasterGeometry = new THREE.SphereGeometry(1.5, 8, 8);
                      const blasterMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 5, metalness: 0.2, roughness: 0.8 });
                      const blaster = new THREE.Mesh(blasterGeometry, blasterMaterial);
                      return { mesh: blaster, active: false, hitEnemies: [] };
                  }, MAX_PLAYER_SHOTS);

                  objectPools.enemyProjectiles = new ObjectPool(() => {
                      const projectileGeometry = new THREE.SphereGeometry(1, 8, 8);
                      const projectileMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff });
                      const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
                      return { mesh: projectile, active: false };
                  }, MAX_ENEMY_SHOTS);

                  // Reset spatial grid
                  spatialGrid.clear();

                  // Hide level up popup if it's open
                  if (isGamePaused) hideLevelUpPopup();

                  gameSpeedMultiplier = 1.0;
                  playerScaleMultiplier = 1.0;
                  playerCone.scale.set(1, 1, 1);
                  playerStats.playerRadius = BASE_PLAYER_RADIUS;

                  enemyCounts = {};
                  Object.keys(enemyPrototypes).forEach(type => enemyCounts[type] = 0);
                  bossCount = 0;
                  lastBossSpawnScore = 0;



                  gemCounts = { damage: 0, speed: 0, attackSpeed: 0, luck: 0, vacuum: 0, crit: 0 };
                  document.getElementById('gem-damage').textContent = 0;
                  document.getElementById('gem-speed').textContent = 0;
                  document.getElementById('gem-attackSpeed').textContent = 0;
                  document.getElementById('gem-luck').textContent = 0;
                  document.getElementById('gem-vacuum').textContent = 0;
                  document.getElementById('gem-crit').textContent = 0;


                  // Reset all stats to their default values
                  playerStats.attackDistance = 100;
                  playerStats.projectileSpeed = 3;
                  playerStats.damage = 30;
                  playerStats.areaDamageRadius = 0;
                  playerStats.pierceCount = 1;
                  playerStats.critChance = 0.05;
                  playerStats.maxHealth = 100;
                  playerStats.armor = 0;
                  playerStats.regenRate = 0;
                  playerStats.dodgeChance = 0;
                  playerStats.attackSpeed = 0.5;
                  playerStats.pickupRadius = 15;
                  playerStats.coinPickupRadius = 115;
                  playerStats.luck = 0.5;
                  playerStats.cooldownReduction = 0;
                  updateStatsUI();

                  lastShotTime = 0;
                  lastOctahedronSpawnTime = 0;
                  maxEnemies = INITIAL_ENEMY_COUNT;

                  playerHealth = playerStats.maxHealth;
                  healthBarElement.style.width = '100%';

                  healthBarShakeUntil = 0;
                  isGameOver = false;
                  isPlayerHit = false;
                  hitAnimationTime = 0;
                  convertingGroup = null;
                  accumulatedRegen = 0;
                  lastRegenNumberTime = 0;

                  // Reset player position
                  playerCone.position.set(0, 3, 5);
                  playerCone.material.color.set(playerConeOriginalColor);
                  playerCone.material.emissive.set(playerConeOriginalColor);

                  // Clear drag visuals
                  clearDragVisuals();
                  movementDirection.set(0, 0);
                  for (let key in keyState) {
          delete keyState[key];
      }
                  isDragging = false;

                  // Remove all enemies
                  for (const enemy of enemies) {
                      // This is a hard reset. We dispose what we can, but avoid disposing
                      // geometry that might be shared with a skeleton that is also being cleared.
                      // The gameplay loop handles per-instance disposal correctly. This is a fallback.
                      if (enemy.wireframe) {
                          enemy.wireframe.geometry.dispose();
                          enemy.wireframe.material.dispose();
                      }
                      if (enemy.mesh.material) enemy.mesh.material.dispose();
                      scene.remove(enemy.mesh);
                  }
                  enemies.length = 0;

                  // Remove all blaster shots
                  for (const shot of blasterShots) {
                      // These are from a pool, which will be disposed, but let's be safe
                      scene.remove(shot.mesh);
                  }
                  blasterShots.length = 0;

                  // Remove all skeletons
                  for (const skeleton of skeletons) {
                      if (skeleton.mesh.material) skeleton.mesh.material.dispose();
                      scene.remove(skeleton.mesh);
                  }
                  skeletons.length = 0;

                  // Remove all coins
                  for (const coin of coins) {
                      // Coin material is a clone, so it should be disposed
                      if (coin.mesh.material) coin.mesh.material.dispose();
                      scene.remove(coin.mesh);
                  }
                  coins.length = 0;

                  // Remove all gems
                  for (const gem of gems) {
                      // Gem geometry is shared, but material is unique
                      if (gem.mesh.material) gem.mesh.material.dispose();
                      scene.remove(gem.mesh);
                  }
                  gems.length = 0;

                  // Remove all enemy projectiles
                  for (const projectile of enemyProjectiles) {
                      scene.remove(projectile.mesh);
                  }
                  enemyProjectiles.length = 0;

                  for (const projectile of enemyProjectiles) {
                      scene.remove(projectile.mesh);
                  }
                  enemyProjectiles.length = 0;

                  // Remove all temporary effects
                  for (const effect of temporaryEffects) {
                      scene.remove(effect.mesh);
                      if (effect.mesh.geometry) effect.mesh.geometry.dispose();
                      if (effect.mesh.material) effect.mesh.material.dispose();
                  }
                  temporaryEffects.length = 0;

                  // Remove all octahedrons
                  for (const group of octahedronGroups) {
                      if (group.octahedron.material) group.octahedron.material.dispose();
                      if (group.ring.geometry) group.ring.geometry.dispose();
                      if (group.ring.material) group.ring.material.dispose();
                      scene.remove(group.octahedron);
                      scene.remove(group.ring);
                      scene.remove(group.light);
                  }
                  octahedronGroups.length = 0;

                  // Re-spawn octahedrons
                  spawnOctahedrons(2, true);

                  // Remove Game Over message if it exists
                  const gameOverElement = document.getElementById('game-over-message');
                  if (gameOverElement) {
                      gameOverElement.remove();
                  }

                  // Hide reset button
                  const resetButton = document.getElementById('reset-button');
                  resetButton.style.display = 'none';

                  // Spawn initial enemies
                   for (let i = 0; i < INITIAL_ENEMY_COUNT; i++) {
                       spawnEnemy();
                   }

                  // Restart animation loop
                  animate();
              }

              const resetButton = document.getElementById('reset-button');
              resetButton.addEventListener('click', resetGame);

              // Start the game
              resetGame();
    </script>
  </body>
</html>
